<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dashboard Gerencial de Receitas - Município</title>

  <!-- PWA + Ícones (para instalar como App no GitHub Pages/HTTPS) -->
  <link rel="manifest" href="./site.webmanifest">
  <meta name="theme-color" content="#0b1020">

  <link rel="icon" href="./favicon.ico">
  <link rel="icon" type="image/svg+xml" href="./favicon.svg">
  <link rel="icon" type="image/png" sizes="96x96" href="./favicon-96x96.png">
  <link rel="apple-touch-icon" href="./apple-touch-icon.png">

  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --panel2:#0c142b;
      --muted:#a7b0c3;
      --text:#e9eefc;
      --line:rgba(255,255,255,.08);
      --accent:#6ee7ff;
      --accent2:#8b5cf6;
      --avg:#f97316;
      --good:#22c55e;
      --warn:#fbbf24;
      --bad:#ef4444;
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius: 18px;
      --page-bg: radial-gradient(1200px 800px at 20% 0%, rgba(110,231,255,.10), transparent 60%),
                  radial-gradient(1200px 800px at 90% 20%, rgba(139,92,246,.12), transparent 55%),
                  linear-gradient(180deg, var(--bg), #060a15);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui, Segoe UI, Arial, sans-serif;
      background: var(--page-bg);
      color:var(--text);
    }

    .app{
      display:grid;
      grid-template-columns: 320px 1fr;
      min-height:100vh;
    }

    .tabBar{
      display:flex;
      gap:8px;
      padding:12px 18px;
      border-bottom:1px solid var(--line);
      background: rgba(15,23,48,.6);
      position:sticky;
      top:0;
      z-index:6;
      backdrop-filter: blur(6px);
    }
    .tabBtn{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      color: var(--text);
      padding:8px 16px;
      border-radius:999px;
      font-weight:600;
      cursor:pointer;
      transition: background .2s ease, border-color .2s ease;
    }
    .tabBtn.active{
      background: linear-gradient(135deg, rgba(110,231,255,.25), rgba(139,92,246,.22));
      border-color: rgba(110,231,255,.5);
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .tabPanels{
      min-height:100vh;
    }
    .tabPanel{
      display:none;
    }
    .tabPanel.active{
      display:block;
    }
    .blankExpense{
      min-height:100vh;
    }

    .sidebar{
      background: linear-gradient(180deg, rgba(255,255,255,.03), transparent 40%),
                  linear-gradient(180deg, var(--panel), var(--panel2));
      border-right:1px solid var(--line);
      padding:18px;
      position:sticky;
      top:0;
      height:100vh;
      overflow:auto;
    }
    .expenseSidebar{
      display:flex;
      flex-direction:column;
      gap:16px;
    }
    .expenseMenu{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin:6px 4px 0;
    }
    .expenseMenuBtn{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:10px 14px;
      border-radius: 14px;
      font-weight:700;
      text-align:left;
      cursor:pointer;
      transition: background .2s ease, border-color .2s ease;
    }
    .expenseMenuBtn.active{
      background: linear-gradient(135deg, rgba(110,231,255,.25), rgba(139,92,246,.22));
      border-color: rgba(110,231,255,.5);
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }

    .brand{
      display:flex;
      gap:12px;
      align-items:center;
      padding:10px 10px 14px;
      border-bottom:1px solid var(--line);
      margin-bottom:14px;
    }
    .logo{
      width:42px;height:42px;border-radius:14px;
      background: rgba(255,255,255,.06) url("./favicon.ico") center/contain no-repeat;
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 10px 26px rgba(0,0,0,.35);
    }
    .brand h1{ font-size:14px; margin:0; font-weight:700; }
    .brand p{ margin:2px 0 0; font-size:12px; color:var(--muted); }

    .sectionTitle{
      margin:16px 6px 8px;
      font-size:11px;
      color:rgba(233,238,252,.75);
      letter-spacing:.14em;
      text-transform:uppercase;
    }

    .ctrl{
      background: rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding:10px;
      margin-bottom:10px;
    }
    .ctrl label{
      display:block;
      font-size:12px;
      color:rgba(233,238,252,.85);
      margin:0 0 6px;
      font-weight:600;
    }
    .ctrl input[type="text"], .ctrl select{
      width:100%;
      padding:10px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      color: var(--text);
      outline:none;
      font-size:13px;
    }
    .ctrl select[multiple]{
      min-height:140px;
    }
    .ctrl input[type="file"]{
      width:100%;
      color:rgba(233,238,252,.85);
      font-size:12px;
    }
    .row{ display:flex; gap:10px; }
    .row > * { flex:1; }

    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:100%;
      padding:11px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(135deg, rgba(110,231,255,.20), rgba(139,92,246,.18));
      color:var(--text);
      font-weight:700;
      cursor:pointer;
      transition: transform .06s ease, opacity .2s ease;
      box-shadow: 0 12px 28px rgba(0,0,0,.30);
    }
    .btn:active{ transform: translateY(1px); }
    .btn.secondary{
      background: rgba(255,255,255,.04);
      box-shadow:none;
      font-weight:600;
    }

    .sortable{
      white-space:nowrap;
    }
    .sortBtn{
      border:none;
      background: rgba(255,255,255,.06);
      color:var(--text);
      border-radius: 999px;
      padding:2px 8px;
      font-size:11px;
      cursor:pointer;
      margin-left:6px;
      border:1px solid rgba(255,255,255,.1);
    }
    .sortBtn.active{
      background: rgba(110,231,255,.18);
      border-color: rgba(110,231,255,.45);
      color: #dff6ff;
    }

    .hint{
      color:var(--muted);
      font-size:12px;
      line-height:1.35;
      margin:8px 6px 0;
    }

    .chipList{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-top:8px;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-size:11px;
      color:rgba(233,238,252,.9);
    }
    .chip button{
      border:none;
      background: transparent;
      color:rgba(233,238,252,.75);
      cursor:pointer;
      font-weight:700;
      padding:0;
    }

    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:8px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color:rgba(233,238,252,.9);
      font-size:12px;
      margin:8px 6px 0;
    }

    .main{
      padding:18px 18px 26px;
      overflow:auto;
    }
    .topbar{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:16px;
      padding:8px 6px 14px;
    }
    .topbarActions{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:10px;
    }
    .titleBlock h2{ margin:0; font-size:18px; }
    .titleBlock .sub{ margin:6px 0 0; color:var(--muted); font-size:12px; }
    .status{ text-align:right; color:var(--muted); font-size:12px; }
    .themeToggle{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:6px 14px;
      border-radius:999px;
      font-size:12px;
      font-weight:600;
      cursor:pointer;
      transition: background .2s ease, border-color .2s ease;
    }
    .themeToggle:hover{
      background: rgba(110,231,255,.18);
      border-color: rgba(110,231,255,.45);
    }

    .gridKpis{
      display:grid;
      grid-template-columns: repeat(5, minmax(180px, 1fr));
      gap:12px;
      margin: 10px 6px 14px;
    }
    .kpi{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      padding:14px;
      box-shadow: var(--shadow);
      min-height: 92px;
    }
    .kpi .label{ font-size:12px; color:rgba(233,238,252,.78); margin:0 0 8px; font-weight:600; }
    .kpi .value{ font-size:18px; font-weight:800; margin:0; }
    .kpi .delta{ margin:8px 0 0; font-size:12px; color:var(--muted); }

    .gridCharts{
      display:grid;
      grid-template-columns: 1.4fr 1fr;
      gap:12px;
      margin: 0 6px 14px;
    }
    .panel{
      background: rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panelHeader{
      padding:12px 14px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .panelHeader h3{ margin:0; font-size:13px; }
    .panelHeader .mini{ color:var(--muted); font-size:12px; }
    .panelMeta{
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .chartLegend{
      display:flex;
      align-items:center;
      gap:12px;
      padding:4px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
    }
    .legendItem{
      display:flex;
      align-items:center;
      gap:6px;
      font-size:12px;
      color:rgba(233,238,252,.82);
      cursor:pointer;
      user-select:none;
    }
    .legendItem input{
      margin:0;
      accent-color: var(--accent);
    }
    .legendItem.is-off{
      color: rgba(233,238,252,.45);
    }
    .legendItem.is-off .legendSwatch{
      opacity:.4;
    }
    .legendSwatch{
      width:10px;
      height:10px;
      border-radius:999px;
      display:inline-block;
      box-shadow: 0 0 0 2px rgba(0,0,0,.2);
    }
    .legendSwatch.total{ background: rgba(110,231,255,.95); }
    .legendSwatch.avg{ background: var(--avg); }
    .legendSwatch.prev{ background: rgba(139,92,246,.95); }
    .panelBody{ padding:10px 10px 8px; }

    #chartSerie{ position:relative; }
    #chartTop{ position:relative; }
    .chartTooltip{
      position:absolute;
      left:0;
      top:0;
      transform: translate(-50%, -120%);
      padding:6px 10px;
      border-radius: 10px;
      background: rgba(12,20,43,.95);
      border:1px solid rgba(255,255,255,.14);
      color: var(--text);
      font-size:12px;
      font-weight:600;
      white-space:nowrap;
      box-shadow: 0 8px 20px rgba(0,0,0,.35);
      opacity:0;
      pointer-events:none;
      transition: opacity .08s ease;
    }
    .chartTooltip.visible{ opacity:1; }

    .builder{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:10px;
      padding:10px;
    }
    .builder .bctrl{
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding:10px;
    }
    .builder label{
      display:block;
      font-size:11px;
      color:rgba(233,238,252,.78);
      letter-spacing:.10em;
      text-transform:uppercase;
      margin-bottom:6px;
    }
    .builder select{
      width:100%;
      padding:10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      color: var(--text);
      outline:none;
      font-size:13px;
    }
    .tabPanel[data-tab="1"] select option{
      background-color: #111a33;
      color: var(--text);
    }
    .tabPanel[data-tab="1"] select option:checked{
      background-color: rgba(110,231,255,.35);
      color: #eef6ff;
    }
    .tabPanel[data-tab="1"] select option:hover,
    .tabPanel[data-tab="1"] select option:focus{
      background-color: rgba(139,92,246,.35);
      color: #f5f7ff;
    }
    .tabPanel[data-tab="1"] select option:disabled{
      color: rgba(233,238,252,.55);
    }

    .tableWrap{ margin: 0 6px; }
    table{ width:100%; border-collapse: collapse; font-size:12px; }
    thead th{
      text-align:left;
      padding:10px 10px;
      color:rgba(233,238,252,.85);
      border-bottom:1px solid var(--line);
      position:sticky;
      top:0;
      background: rgba(12,18,40,.95);
      backdrop-filter: blur(8px);
      z-index:1;
    }
    tbody td{
      padding:10px 10px;
      border-bottom:1px solid rgba(255,255,255,.06);
      color:rgba(233,238,252,.90);
    }
    tbody tr:hover{ background: rgba(255,255,255,.03); }
    tbody tr.selected{ background: rgba(110,231,255,.10); }

    .clickFilter{
      cursor:pointer;
    }
    .clickFilter:hover{
      color: var(--accent);
      text-decoration: underline;
    }
    .clickSelect{
      cursor:pointer;
    }
    .clickSelect:hover{
      color: var(--accent);
      text-decoration: underline;
    }

    .searchRow{
      display:flex;
      gap:10px;
      padding:10px;
      border-bottom:1px solid var(--line);
      align-items:center;
    }
    .searchRow input{
      flex:1;
      padding:10px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      color: var(--text);
      outline:none;
      font-size:13px;
    }
    .selectAllBox{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      font-size:12px;
      color:rgba(233,238,252,.9);
      white-space:nowrap;
    }
    .selectAllBox input{
      accent-color: var(--accent);
    }
    .selectAllBox label{
      cursor:pointer;
    }

    .chartCanvas{
      width:100%;
      height:100%;
      display:block;
      border-radius: 14px;
      background: rgba(0,0,0,.12);
      border:1px solid rgba(255,255,255,.08);
    }

    .chartClickable{ cursor:pointer; }

    .errorBox{
      margin: 0 6px 14px;
      padding:12px 14px;
      border-radius: 14px;
      border: 1px solid rgba(239,68,68,.35);
      background: rgba(239,68,68,.10);
      color: rgba(233,238,252,.92);
      display:none;
      white-space:pre-wrap;
      line-height:1.35;
      font-size:12px;
    }

    body[data-theme="light"]{
      --bg:#f8fafc;
      --panel:#ffffff;
      --panel2:#f1f5f9;
      --muted:#475569;
      --text:#0f172a;
      --line: rgba(15,23,42,.18);
      --accent:#0ea5e9;
      --accent2:#6366f1;
      --avg:#ea580c;
      --good:#16a34a;
      --warn:#f59e0b;
      --bad:#dc2626;
      --shadow: 0 14px 32px rgba(15,23,42,.12);
      --page-bg: radial-gradient(1200px 800px at 20% 0%, rgba(14,165,233,.14), transparent 60%),
                  radial-gradient(1200px 800px at 90% 20%, rgba(99,102,241,.12), transparent 55%),
                  linear-gradient(180deg, #f8fafc, #eef2f7);
    }
    body[data-theme="light"] .tabBar{
      background: rgba(255,255,255,.92);
    }
    body[data-theme="light"] .tabBtn{
      border-color: rgba(15,23,42,.2);
      background: rgba(15,23,42,.05);
      color: var(--text);
    }
    body[data-theme="light"] .tabBtn.active{
      color: #0f172a;
      box-shadow: 0 8px 18px rgba(15,23,42,.15);
    }
    body[data-theme="light"] .sidebar{
      background: linear-gradient(180deg, rgba(15,23,42,.05), transparent 40%),
                  linear-gradient(180deg, var(--panel), var(--panel2));
    }
    body[data-theme="light"] .logo{
      background-color: rgba(15,23,42,.06);
      border-color: rgba(15,23,42,.18);
      box-shadow: 0 8px 18px rgba(15,23,42,.15);
    }
    body[data-theme="light"] .sectionTitle{
      color: rgba(15,23,42,.7);
    }
    body[data-theme="light"] .ctrl{
      background: rgba(15,23,42,.03);
      border-color: rgba(15,23,42,.15);
    }
    body[data-theme="light"] .ctrl label{
      color: rgba(15,23,42,.8);
    }
    body[data-theme="light"] .ctrl input[type="text"],
    body[data-theme="light"] .ctrl select{
      background: rgba(255,255,255,.95);
      border-color: rgba(15,23,42,.2);
      color: var(--text);
    }
    body[data-theme="light"] .ctrl input[type="file"]{
      color: rgba(15,23,42,.8);
    }
    body[data-theme="light"] .btn.secondary{
      background: rgba(15,23,42,.06);
      border-color: rgba(15,23,42,.2);
      color: var(--text);
    }
    body[data-theme="light"] .sortBtn{
      background: rgba(15,23,42,.08);
      border-color: rgba(15,23,42,.2);
      color: var(--text);
    }
    body[data-theme="light"] .chip,
    body[data-theme="light"] .pill{
      background: rgba(15,23,42,.06);
      border-color: rgba(15,23,42,.18);
      color: rgba(15,23,42,.85);
    }
    body[data-theme="light"] .chip button{
      color: rgba(15,23,42,.6);
    }
    body[data-theme="light"] .kpi{
      background: linear-gradient(180deg, rgba(255,255,255,.98), rgba(15,23,42,.03));
      border-color: rgba(15,23,42,.15);
    }
    body[data-theme="light"] .kpi .label{
      color: rgba(15,23,42,.75);
    }
    body[data-theme="light"] .panel{
      background: rgba(255,255,255,.96);
      border-color: rgba(15,23,42,.15);
    }
    body[data-theme="light"] .chartLegend{
      background: rgba(15,23,42,.04);
      border-color: rgba(15,23,42,.12);
    }
    body[data-theme="light"] .legendItem{
      color: rgba(15,23,42,.8);
    }
    body[data-theme="light"] .legendItem.is-off{
      color: rgba(15,23,42,.45);
    }
    body[data-theme="light"] .chartTooltip{
      background: rgba(255,255,255,.98);
      border-color: rgba(15,23,42,.2);
      color: var(--text);
      box-shadow: 0 8px 20px rgba(15,23,42,.15);
    }
    body[data-theme="light"] .builder .bctrl{
      background: rgba(255,255,255,.9);
      border-color: rgba(15,23,42,.15);
    }
    body[data-theme="light"] .builder label{
      color: rgba(15,23,42,.7);
    }
    body[data-theme="light"] .builder select{
      background: rgba(255,255,255,.95);
      border-color: rgba(15,23,42,.2);
      color: var(--text);
    }
    body[data-theme="light"] .tabPanel[data-tab="1"] select option{
      background-color: #f1f5f9;
      color: #0f172a;
    }
    body[data-theme="light"] .tabPanel[data-tab="1"] select option:checked{
      background-color: rgba(14,165,233,.25);
      color: #0f172a;
    }
    body[data-theme="light"] .tabPanel[data-tab="1"] select option:hover,
    body[data-theme="light"] .tabPanel[data-tab="1"] select option:focus{
      background-color: rgba(99,102,241,.2);
      color: #0f172a;
    }
    body[data-theme="light"] thead th{
      background: rgba(248,250,252,.98);
      color: rgba(15,23,42,.9);
    }
    body[data-theme="light"] tbody td{
      color: rgba(15,23,42,.9);
      border-bottom:1px solid rgba(15,23,42,.1);
    }
    body[data-theme="light"] tbody tr:hover{
      background: rgba(15,23,42,.04);
    }
    body[data-theme="light"] .searchRow input{
      background: rgba(255,255,255,.95);
      border-color: rgba(15,23,42,.2);
      color: var(--text);
    }
    body[data-theme="light"] .selectAllBox{
      background: rgba(255,255,255,.95);
      border-color: rgba(15,23,42,.2);
      color: rgba(15,23,42,.85);
    }
    body[data-theme="light"] .chartCanvas{
      background: rgba(255,255,255,.96);
      border-color: rgba(15,23,42,.12);
    }
    body[data-theme="light"] .errorBox{
      color: rgba(15,23,42,.9);
    }
    body[data-theme="light"] .themeToggle{
      background: rgba(15,23,42,.06);
      border-color: rgba(15,23,42,.2);
    }
    body[data-theme="light"] .expenseMenuBtn{
      background: rgba(15,23,42,.06);
      border-color: rgba(15,23,42,.2);
      color: var(--text);
    }
    body[data-theme="light"] .expenseMenuBtn.active{
      box-shadow: 0 8px 18px rgba(15,23,42,.15);
    }
    .expenseUpload{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin:6px 4px 0;
    }
    .expenseUpload .ctrl{
      margin-bottom:0;
    }
    .expenseUpload .row{
      align-items:center;
    }
    .expenseUpload .row input[type="text"]{
      flex:1;
    }
    .expenseLegend{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      font-size:12px;
      color:rgba(233,238,252,.8);
    }
    .expenseLegendItem{
      display:flex;
      align-items:center;
      gap:6px;
      padding:4px 8px;
      border-radius:999px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.12);
      color:inherit;
      font: inherit;
    }
    .expenseLegendToggle{
      appearance:none;
      cursor:pointer;
    }
    .expenseLegendToggle.is-off{
      opacity:.45;
    }
    .expenseLegendToggle:focus-visible{
      outline:2px solid rgba(110,231,255,.6);
      outline-offset:2px;
    }
    .expenseLegendSwatch{
      width:10px;
      height:10px;
      border-radius:999px;
      display:inline-block;
    }
    .expenseContent{
      display:none;
    }
    .expenseContent.active{
      display:block;
    }
    .expenseElementLayout{
      display:grid;
      grid-template-columns: minmax(220px, 280px) 1fr;
      gap:14px;
      align-items:start;
    }
    .expenseElementFilters{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .expenseFilterCard{
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding:12px;
    }
    .expenseFilterTitle{
      font-size:12px;
      font-weight:700;
      margin:0 0 8px;
      color:rgba(233,238,252,.85);
      text-transform:uppercase;
      letter-spacing:.08em;
    }
    .expenseFilterSearch{
      width:100%;
      padding:9px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color:var(--text);
      font-size:12px;
      outline:none;
    }
    .expenseFilterActions{
      display:flex;
      gap:8px;
      margin:8px 0 10px;
      flex-wrap:wrap;
    }
    .expenseFilterBtn{
      flex:1;
      padding:7px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.04);
      color:var(--text);
      font-size:11px;
      font-weight:700;
      cursor:pointer;
      transition: background .2s ease, border-color .2s ease;
    }
    .expenseFilterBtn.active{
      background: linear-gradient(135deg, rgba(110,231,255,.22), rgba(139,92,246,.18));
      border-color: rgba(110,231,255,.5);
    }
    .expenseFilterOptions{
      display:flex;
      flex-direction:column;
      gap:8px;
      font-size:12px;
      max-height:220px;
      overflow:auto;
      padding-right:4px;
    }
    .expenseFilterEmpty{
      font-size:11px;
      color:rgba(233,238,252,.55);
      margin-top:10px;
      display:none;
    }
    .expenseFilterOption{
      display:flex;
      align-items:flex-start;
      gap:8px;
      cursor:pointer;
      color:rgba(233,238,252,.86);
    }
    .expenseFilterOption input{
      margin-top:2px;
      accent-color: var(--accent);
    }
    .expenseElementChartWrap{
      min-height:360px;
      position:relative;
    }
    .chartTooltip{
      position:absolute;
      z-index:6;
      padding:8px 10px;
      border-radius:10px;
      background: rgba(15,23,48,.95);
      border:1px solid rgba(255,255,255,.2);
      color:var(--text);
      font-size:12px;
      line-height:1.35;
      box-shadow: var(--shadow);
      pointer-events:none;
      opacity:0;
      transform: translate(-50%, -8px);
      transition: opacity .12s ease;
      white-space: nowrap;
    }
    .chartTooltip strong{
      display:block;
      font-size:12px;
    }

    body[data-theme="light"] .expenseFilterCard{
      background: rgba(255,255,255,.9);
      border-color: rgba(15,23,42,.15);
    }
    body[data-theme="light"] .expenseFilterTitle{
      color: rgba(15,23,42,.75);
    }
    body[data-theme="light"] .expenseFilterSearch{
      background: rgba(15,23,42,.05);
      border-color: rgba(15,23,42,.2);
      color: #0f172a;
    }
    body[data-theme="light"] .expenseFilterBtn{
      background: rgba(15,23,42,.05);
      border-color: rgba(15,23,42,.2);
      color: #0f172a;
    }
    body[data-theme="light"] .expenseFilterOption{
      color: rgba(15,23,42,.85);
    }
    body[data-theme="light"] .expenseFilterEmpty{
      color: rgba(15,23,42,.55);
    }

    @media (max-width: 1280px){
      .gridKpis{ grid-template-columns: repeat(3, minmax(180px, 1fr)); }
      .gridCharts{ grid-template-columns: 1fr; }
      .builder{ grid-template-columns: repeat(2, 1fr); }
      .expenseElementLayout{ grid-template-columns: 1fr; }
    }
    @media (max-width: 980px){
      .app{ grid-template-columns: 1fr; }
      .sidebar{ position:relative; height:auto; }
    }
  </style>
</head>

<body>
<div class="tabBar" role="tablist" aria-label="Abas do dashboard">
  <button class="tabBtn active" type="button" role="tab" aria-selected="true" data-tab="1">Receitas</button>
  <button class="tabBtn" type="button" role="tab" aria-selected="false" data-tab="2">Despesas</button>
</div>
<div class="tabPanels">
  <div class="tabPanel active" role="tabpanel" data-tab="1">
<div class="app">
  <aside class="sidebar">
    <div class="brand">
      <div class="logo"></div>
      <div>
        <h1>Receitas Municipais</h1>
        <p>Dashboard Gerencial </p>
      </div>
    </div>

    <div class="sectionTitle">Fonte de dados</div>

    <div class="ctrl">
      <label>Nome do município</label>
      <input id="municipio" type="text" placeholder="Ex.: Camocim de São Félix" />
    </div>

    <div class="ctrl">
      <label>Upload do arquivo (CSV)</label>
      <input id="fileInput" type="file" accept=".csv,.txt" />
      <div class="hint">
        Use CSV do Excel (geralmente separado por <b>;</b>).
        Cabeçalho esperado: ficha | natureza | nome | orçado | janeiro..dezembro (opcional: entidade, fonte de recurso)
      </div>
    </div>
    <div class="ctrl">
      <label>Upload do arquivo do ano anterior (CSV)</label>
      <input id="fileInputPrev" type="file" accept=".csv,.txt" />
      <div class="hint">
        Opcional. Use o mesmo layout do arquivo principal para comparar os dois anos.
      </div>
    </div>
    <div class="ctrl">
      <label>Upload do arquivo do ano anterior (CSV)</label>
      <input id="fileInputPrev" type="file" accept=".csv,.txt" />
      <div class="hint">
        Opcional. Use o mesmo layout do arquivo principal para comparar os dois anos.
      </div>
    </div>

    <button class="btn" id="btnProcessar">Carregar & Atualizar</button>
    <button class="btn secondary" id="btnLimpar" style="margin-top:10px;">Limpar dados salvos</button>

    <div class="sectionTitle">Filtros</div>

    <div class="ctrl row">
      <div>
        <label>Ano (opcional)</label>
        <input id="ano" type="text" placeholder="Ex.: 2025" />
      </div>
      <div>
        <label>Mês foco</label>
        <select id="mesFoco"></select>
      </div>
    </div>
    <div class="ctrl">
      <label>Meses visíveis (Receitas por mês)</label>
      <select id="mesVisualizacao" multiple></select>
      <div class="hint">Selecione um ou mais meses para filtrar o gráfico.</div>
    </div>
    <div class="ctrl">
      <label>Ano anterior (opcional)</label>
      <input id="anoAnterior" type="text" placeholder="Ex.: 2024" />
    </div>
    <div class="ctrl">
      <label>Ano anterior (opcional)</label>
      <input id="anoAnterior" type="text" placeholder="Ex.: 2024" />
    </div>

    <div class="ctrl">
      <label>Dimensão (Top / Agrupamentos)</label>
      <select id="dimensao">
        <option value="natureza">Natureza da Receita</option>
        <option value="ficha">Ficha</option>
        <option value="nome">Nome da Ficha</option>
        <option value="entidade">Entidade</option>
        <option value="fonteRecurso">Fonte de recurso</option>
      </select>
    </div>

    <div class="ctrl">
      <label>Tipo (Receita por mês)</label>
      <select id="tipoSerie">
        <option value="line">Linha</option>
        <option value="bar">Barras</option>
      </select>
    </div>

    <div class="ctrl">
      <label>Pesquisa rápida (filtra tabela)</label>
      <input id="quickSearch" type="text" placeholder="Ex.: IPTU, ITBI, IRRF..." />
    </div>

    <div class="ctrl">
      <label>Entidade (multi-seleção)</label>
      <select id="entidadeFilter" multiple></select>
      <div class="hint">Use Ctrl/Cmd para selecionar mais de uma opção.</div>
    </div>

    <div class="ctrl">
      <label>Fonte de recurso (multi-seleção)</label>
      <select id="fonteFilter" multiple></select>
      <div class="hint">Use Ctrl/Cmd para selecionar mais de uma opção.</div>
    </div>

    <div class="ctrl">
      <label>Fichas selecionadas</label>
      <div class="row" style="align-items:center;">
        <div class="hint" style="margin:0;">Clique na tabela ou no gráfico para marcar.</div>
        <button class="btn secondary" id="btnLimparFichas" style="max-width:140px;">Limpar</button>
      </div>
      <div class="chipList" id="fichaChips"></div>
    </div>

    <div class="pill" id="pillStatus">Nenhum arquivo carregado</div>
    <div class="hint">Tudo roda local no seu navegador (offline).</div>
  </aside>

  <main class="main">
    <div class="topbar">
      <div class="titleBlock">
        <h2 id="titulo">Dashboard de Receitas</h2>
        <div class="sub" id="subtitulo">Faça upload do arquivo para iniciar.</div>
      </div>
      <div class="topbarActions">
        <button class="themeToggle" type="button" aria-pressed="false">Tema: Escuro</button>
        <div class="status">
          <div id="statusArquivo">Fonte: —</div>
          <div id="statusArquivoAnterior">Ano anterior: —</div>
          <div id="statusAtualizacao">Atualização: —</div>
        </div>
      </div>
    </div>

    <div class="errorBox" id="errorBox"></div>

    <section class="gridKpis">
  <div class="kpi">
    <div class="label">Orçado (Total)</div>
    <div class="value" id="kpiOrcado">R$ 0,00</div>
    <div class="delta" id="kpiOrcadoObs">—</div>
  </div>

  <!-- TROCOU: Mês selecionado vem aqui -->
  <div class="kpi">
    <div class="label">Mês selecionado</div>
    <div class="value" id="kpiMes">R$ 0,00</div>
    <div class="delta" id="kpiMesObs">—</div>
  </div>

  <div class="kpi">
    <div class="label">Execução (% Orçado)</div>
    <div class="value" id="kpiExec">0,00%</div>
    <div class="delta" id="kpiExecObs">—</div>
  </div>

  <!-- TROCOU: Arrecadado (Ano) vem aqui -->
  <div class="kpi">
    <div class="label">Arrecadado (Ano)</div>
    <div class="value" id="kpiArrecAno">R$ 0,00</div>
    <div class="delta" id="kpiArrecAnoObs">—</div>
  </div>

  <div class="kpi">
    <div class="label">Variação vs mês anterior</div>
    <div class="value" id="kpiVar">—</div>
    <div class="delta" id="kpiVarObs">—</div>
  </div>
</section>


    <section class="gridCharts">
      <div class="panel">
        <div class="panelHeader">
          <h3>Receitas por mês (Total)</h3>
          <div class="panelMeta">
            <div class="mini" id="miniPeriodo">jan..dez</div>
            <div class="chartLegend" aria-label="Legenda do gráfico de receitas por mês">
              <label class="legendItem" data-series-label="total">
                <input type="checkbox" data-series="total" checked />
                <span class="legendSwatch total" aria-hidden="true"></span>
                Total
              </label>
              <label class="legendItem" data-series-label="avg">
                <input type="checkbox" data-series="avg" checked />
                <span class="legendSwatch avg" aria-hidden="true"></span>
                Média
              </label>
              <label class="legendItem" data-series-label="prev">
                <input type="checkbox" data-series="prev" checked />
                <span class="legendSwatch prev" aria-hidden="true"></span>
                <span id="legendPrevLabel">Ano anterior</span>
              </label>
            </div>
          </div>
        </div>
        <div class="panelBody">
          <div id="chartSerie" style="height:360px;"></div>
        </div>
      </div>

      <div class="panel">
        <div class="panelHeader">
          <h3>Top receitas (por dimensão)</h3>
          <div class="mini" id="miniDim">Natureza</div>
        </div>
        <div class="panelBody">
          <div id="chartTop" style="height:360px;"></div>
        </div>
      </div>
    </section>

    <section class="panel" style="margin:0 6px 14px;">
      <div class="panelHeader">
        <h3>Construtor de visualização</h3>
        <div class="mini">Escolha o insight (métrica x dimensão)</div>
      </div>
      <div class="builder">
        <div class="bctrl">
          <label>Tipo</label>
          <select id="bTipo">
            <option value="bar">Barras</option>
            <option value="line">Linha</option>
            <option value="barstack">Barras empilhadas</option>
          </select>
        </div>
        <div class="bctrl">
          <label>Métrica</label>
          <select id="bMetrica">
            <option value="mes">Arrecadado no mês foco</option>
            <option value="acum">Arrecadado acumulado (ano)</option>
            <option value="orc">Orçado</option>
            <option value="exec">% Execução (acum/orçado)</option>
          </select>
        </div>
        <div class="bctrl">
          <label>Eixo X</label>
          <select id="bEixo">
            <option value="dim">Dimensão selecionada (sidebar)</option>
            <option value="meses">Meses (jan..dez)</option>
          </select>
        </div>
        <div class="bctrl">
          <label>Agrupar por</label>
          <select id="bAgrupar">
            <option value="none">Sem grupos</option>
            <option value="natureza">Natureza</option>
            <option value="ficha">Ficha</option>
          </select>
        </div>
      </div>
      <div class="panelBody" style="padding-top:0;">
        <div id="chartBuilder" style="height:420px;"></div>
      </div>
    </section>

    <section class="panel tableWrap">
      <div class="panelHeader">
        <h3>Tabela detalhada</h3>
        <div class="mini" id="miniLinhas">0 linhas</div>
      </div>
      <div class="searchRow">
        <input id="tableSearch" type="text" placeholder="Buscar na tabela (ex.: IPTU, ITBI, 1112.50...)" />
        <div class="selectAllBox">
          <input id="selectAllFiltered" type="checkbox" />
          <label for="selectAllFiltered">Selecionar filtradas</label>
        </div>
        <button class="btn secondary" id="btnExportCSV" style="max-width:220px;">Exportar visão (CSV)</button>
      </div>
      <div style="max-height:420px; overflow:auto;">
        <table>
          <thead>
            <tr>
              <th class="sortable">Ficha
                <button class="sortBtn" data-sort="ficha" aria-label="Ordenar por ficha">⇅</button>
              </th>
              <th class="sortable">Natureza
                <button class="sortBtn" data-sort="natureza" aria-label="Ordenar por natureza">⇅</button>
              </th>
              <th class="sortable">Nome
                <button class="sortBtn" data-sort="nome" aria-label="Ordenar por nome">⇅</button>
              </th>
              <th>Orçado</th>
              <th id="thMesFoco">Mês</th>
              <th>Acumulado</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
    </section>

    <div class="hint" style="margin:12px 6px 0;">
      Dica: se o Excel gerar CSV com <b>;</b>, este dashboard detecta automaticamente.
    </div>
  </main>
</div>
  </div>
  <div class="tabPanel" role="tabpanel" data-tab="2">
    <div class="app blankExpense" aria-label="Aba de despesas em branco">
      <aside class="sidebar expenseSidebar">
        <div class="brand">
          <div class="logo"></div>
          <div>
            <h1>Despesas Municipais</h1>
            <p>Dashboard Gerencial</p>
          </div>
        </div>
        <div class="sectionTitle">Upload despesas (até 3 anos)</div>
        <div class="expenseUpload" aria-label="Upload de arquivos de despesas">
          <div class="ctrl">
            <label>Arquivo 1 (Excel ou CSV)</label>
            <input id="expenseFile1" type="file" accept=".csv,.xlsx,.xls" />
            <div class="row" style="margin-top:8px;">
              <label style="margin:0; min-width:90px;">Ano (opcional)</label>
              <input id="expenseYear1" type="text" placeholder="Ex.: 2025" />
            </div>
          </div>
          <div class="ctrl">
            <label>Arquivo 2 (Excel ou CSV)</label>
            <input id="expenseFile2" type="file" accept=".csv,.xlsx,.xls" />
            <div class="row" style="margin-top:8px;">
              <label style="margin:0; min-width:90px;">Ano (opcional)</label>
              <input id="expenseYear2" type="text" placeholder="Ex.: 2024" />
            </div>
          </div>
          <div class="ctrl">
            <label>Arquivo 3 (Excel ou CSV)</label>
            <input id="expenseFile3" type="file" accept=".csv,.xlsx,.xls" />
            <div class="row" style="margin-top:8px;">
              <label style="margin:0; min-width:90px;">Ano (opcional)</label>
              <input id="expenseYear3" type="text" placeholder="Ex.: 2023" />
            </div>
            <div class="hint" style="margin:8px 0 0;">
              Formato esperado: EMPENHO | DATA | VALOR | NATUREZA DA DESPESA | ORGÃO | FUNÇÃO | SUBFUNÇÃO | FONTE_STN | VALOR PAGO
            </div>
          </div>
          <button class="btn" id="expenseLoadBtn" type="button">Carregar dados</button>
          <div class="pill" id="expenseStatus">Nenhum arquivo carregado</div>
        </div>
        <div>
          <div class="sectionTitle">Menu</div>
          <nav class="expenseMenu" aria-label="Menu de despesas">
            <button class="expenseMenuBtn active" type="button" aria-current="page" data-expense-view="elemento">Por Elemento</button>
            <button class="expenseMenuBtn" type="button" data-expense-view="grupo">Por Grupo</button>
          </nav>
        </div>
      </aside>
      <main class="main">
        <div class="topbar">
          <div class="titleBlock">
            <h2>Dashboard de Despesas</h2>
            <div class="sub">Em construção.</div>
          </div>
          <div class="topbarActions">
            <button class="themeToggle" type="button" aria-pressed="false">Tema: Escuro</button>
          </div>
        </div>
        <div class="errorBox" id="expenseError"></div>
        <section class="expenseContent active" data-expense-view="elemento">
          <section class="panel" style="margin:0 6px 14px;">
            <div class="panelHeader">
              <h3>Comparativo por elemento</h3>
              <div class="mini" id="expenseElementSummary">Selecione elementos para comparar.</div>
            </div>
            <div class="panelBody">
              <div class="expenseElementLayout">
                <div class="expenseElementFilters">
                  <div class="expenseFilterCard">
                    <div class="expenseFilterTitle">Elementos</div>
                    <input id="expenseElementSearch" class="expenseFilterSearch" type="text" placeholder="Filtrar elementos..." />
                    <div class="expenseFilterActions">
                      <button class="expenseFilterBtn" id="expenseElementSelectAll" type="button">Selecionar todos</button>
                      <button class="expenseFilterBtn" id="expenseElementRemoveZero" type="button">Remover valores zerados</button>
                      <button class="expenseFilterBtn" id="expenseElementClear" type="button">Desselecionar</button>
                    </div>
                    <div class="expenseFilterOptions" id="expenseElementOptions"></div>
                    <div class="expenseFilterEmpty" id="expenseElementEmpty">Digite para buscar novos elementos.</div>
                  </div>
                  <div class="expenseFilterCard">
                    <div class="expenseFilterTitle">Legenda (anos)</div>
                    <div class="expenseLegend" id="expenseElementLegend"></div>
                  </div>
                </div>
              <div class="expenseElementChartWrap">
                <div id="expenseElementChart" style="height:360px;"></div>
                <div class="chartTooltip" id="expenseElementTooltip" role="status" aria-live="polite"></div>
              </div>
            </div>
          </div>
        </section>
        </section>
        <section class="expenseContent" data-expense-view="grupo">
          <section class="panel" style="margin:0 6px 14px;">
            <div class="panelHeader">
              <h3>Despesas por mês (linhas simples)</h3>
              <div class="expenseLegend" id="expenseLegend"></div>
            </div>
            <div class="panelBody">
              <div id="expenseChart" style="height:360px;"></div>
            </div>
          </section>
        </section>
      </main>
    </div>
  </div>
</div>

<script src="./xlsx.full.min.js"></script>
<script>
/* ==============================
   Meses + utilitários
================================*/
const MONTHS = [
  {key:"janeiro", label:"Janeiro", aliases:["janeiro","jan"]},
  {key:"fevereiro", label:"Fevereiro", aliases:["fevereiro","fev"]},
  {key:"marco", label:"Março", aliases:["marco","março","mar"]},
  {key:"abril", label:"Abril", aliases:["abril","abr"]},
  {key:"maio", label:"Maio", aliases:["maio","mai"]},
  {key:"junho", label:"Junho", aliases:["junho","jun"]},
  {key:"julho", label:"Julho", aliases:["julho","jul"]},
  {key:"agosto", label:"Agosto", aliases:["agosto","ago"]},
  {key:"setembro", label:"Setembro", aliases:["setembro","set"]},
  {key:"outubro", label:"Outubro", aliases:["outubro","out"]},
  {key:"novembro", label:"Novembro", aliases:["novembro","nov"]},
  {key:"dezembro", label:"Dezembro", aliases:["dezembro","dez"]},
];

function normalizeText(s){
  return (s ?? "")
    .toString()
    .trim()
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "");
}
function isNaturePrefixQuery(q){
  return /^[0-9.]+$/.test(q);
}
function matchesTableQuery(row, q){
  if (!q) return true;
  if (isNaturePrefixQuery(q)){
    const natureza = normalizeText(row.natureza || "");
    return natureza.startsWith(q);
  }
  return row._search.includes(q);
}

function buildSearchIndex(row){
  return normalizeText([
    row.ficha,
    row.natureza,
    row.nome,
    row.entidade,
    row.fonteRecurso,
  ].join(" "));
}

function parseBRNumber(v){
  if (v === null || v === undefined) return 0;
  if (typeof v === "number") return isFinite(v) ? v : 0;
  let s = v.toString().trim();
  if (!s) return 0;
  s = s.replace(/[R$\s]/g, "");
  if (s.includes(",")) s = s.replace(/\./g, "").replace(",", ".");
  s = s.replace(/%/g, "");
  const n = Number(s);
  return isFinite(n) ? n : 0;
}
function moneyBR(n){
  return (n || 0).toLocaleString("pt-BR", {style:"currency", currency:"BRL"});
}
function pctBR(n){
  return (n || 0).toLocaleString("pt-BR", {minimumFractionDigits:2, maximumFractionDigits:2}) + "%";
}

/* ==============================
   CSV robusto (detecta ; , \t + aspas)
================================*/
function detectDelimiter(sampleLine){
  const counts = {
    ";": (sampleLine.match(/;/g) || []).length,
    ",": (sampleLine.match(/,/g) || []).length,
    "\t": (sampleLine.match(/\t/g) || []).length
  };
  return Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0] || ";";
}

function parseCSV(text){
  text = text.replace(/^\uFEFF/, ""); // remove BOM
  text = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n");

  const firstLine = (text.split("\n").find(l => l.trim().length>0) || "");
  const sep = detectDelimiter(firstLine);

  const rows = [];
  let row = [];
  let cur = "";
  let inQuotes = false;

  for (let i=0; i<text.length; i++){
    const ch = text[i];

    if (ch === '"'){
      if (inQuotes && text[i+1] === '"'){ cur += '"'; i++; }
      else inQuotes = !inQuotes;
      continue;
    }

    if (!inQuotes && ch === sep){
      row.push(cur); cur = ""; continue;
    }

    if (!inQuotes && ch === "\n"){
      row.push(cur); cur = "";
      if (row.some(c => (c||"").trim() !== "")) rows.push(row);
      row = [];
      continue;
    }

    cur += ch;
  }

  row.push(cur);
  if (row.some(c => (c||"").trim() !== "")) rows.push(row);

  return {rows, sep};
}

function toObjects(rows){
  if (!rows.length) return {header:[], objs:[]};
  const header = rows[0].map(h => (h ?? "").toString().trim());
  const objs = [];
  for (let i=1;i<rows.length;i++){
    const r = rows[i];
    const o = {};
    for (let c=0;c<header.length;c++){
      const k = header[c] || `col${c+1}`;
      o[k] = r[c] ?? "";
    }
    objs.push(o);
  }
  return {header, objs};
}

/* ==============================
   Detecção de colunas
================================*/
function pickColumnKey(keys, targets){
  const cand = keys.map(k => ({k, nk: normalizeText(k)}));
  const wanted = (Array.isArray(targets) ? targets : [targets]).map(t => normalizeText(t));

  // match exato
  for (const t of wanted){
    const direct = cand.find(c => c.nk === t);
    if (direct) return direct.k;
  }

  // contém
  for (const t of wanted){
    const contains = cand.find(c => c.nk.includes(t));
    if (contains) return contains.k;
  }

  // palavras
  for (const t of wanted){
    const words = t.split(/\s+/).filter(Boolean);
    const allWords = cand.find(c => words.every(w => c.nk.includes(w)));
    if (allWords) return allWords.k;
  }

  return null;
}

function normalizeDataset(raw){
  if (!raw || raw.length === 0) return [];

  const keys = Object.keys(raw[0] || {});

  const colFicha = pickColumnKey(keys, ["ficha"]);
  const colNatureza = pickColumnKey(keys, ["natureza", "natureza da receita", "natureza da rec", "natureza da rec."]);
  const colNome = pickColumnKey(keys, ["nome", "nome da ficha", "nome da receita"]);
  const colOrcado = pickColumnKey(keys, ["orcado", "orçado", "orcamento", "orçamento"]);
  const colEntidade = pickColumnKey(keys, ["entidade"]);
  const colFonteRecurso = pickColumnKey(keys, ["fonte de recurso", "fonte recurso", "fonte de recursos"]);

  if (!colFicha || !colNatureza || !colNome || !colOrcado){
    throw new Error(
      "Cabeçalho não reconhecido.\n\n" +
      "Colunas detectadas:\n- " + keys.join("\n- ") + "\n\n" +
      "Precisa ter pelo menos:\n" +
      "- ficha\n- natureza\n- nome\n- orçado\n- janeiro..dezembro\n\n" +
      "Dica: no Excel, mantenha esses títulos na primeira linha."
    );
  }

  const monthCols = {};
  for (const m of MONTHS){
    const found = keys.find(k => m.aliases.includes(normalizeText(k)));
    if (found) monthCols[m.key] = found;
  }

  if (!monthCols.janeiro){
    throw new Error(
      "Não encontrei a coluna 'janeiro' no cabeçalho.\n\n" +
      "Colunas detectadas:\n- " + keys.join("\n- ")
    );
  }

  const out = [];
  for (const r of raw){
    const ficha = (r[colFicha] ?? "").toString().trim();
    const natureza = (r[colNatureza] ?? "").toString().trim();
    const nome = (r[colNome] ?? "").toString().trim();
    const orcado = parseBRNumber(r[colOrcado]);
    const entidade = colEntidade ? (r[colEntidade] ?? "").toString().trim() : "";
    const fonteRecurso = colFonteRecurso
      ? normalizeFonteRecursoValue(r[colFonteRecurso])
      : "";

    const values = {};
    for (const m of MONTHS){
      const ck = monthCols[m.key];
      values[m.key] = ck ? parseBRNumber(r[ck]) : 0;
    }

    const isEmpty =
      !ficha && !natureza && !nome &&
      orcado === 0 &&
      Object.values(values).every(v => v === 0);

    if (isEmpty) continue;

    out.push({
      ficha, natureza, nome, orcado, values, entidade, fonteRecurso,
      _search: buildSearchIndex({ ficha, natureza, nome, entidade, fonteRecurso }),
    });
  }
  return out;
}

function normalizeFonteRecursoValue(value){
  const trimmed = (value ?? "").toString().trim();
  if (!trimmed) return "";

  const dotMatch = trimmed.match(/(\d\.\d{3})/);
  if (dotMatch) return dotMatch[1];

  const compact = trimmed.replace(/\s+/g, "");
  if (/^\d\.\d{3}$/.test(compact)) return compact;
  if (/^\d{4}$/.test(compact)) return `${compact[0]}.${compact.slice(1)}`;

  const digits = compact.replace(/\D/g, "");
  if (digits.length === 4) return `${digits[0]}.${digits.slice(1)}`;

  return trimmed;
}

function abbreviateEntidade(entidade){
  const normalized = normalizeText(entidade);
  if (!normalized) return entidade;

  if (normalized.includes("acao social")){
    return "FMAS";
  }
  if (normalized.includes("saude")){
    return "FMS";
  }
  if (normalized.includes("prefeitura")){
    return "PM";
  }
  return entidade;
}

function applyEntidadeAbbreviations(rows){
  for (const row of rows){
    const original = row.entidade || "";
    const abbreviated = abbreviateEntidade(original);
    if (abbreviated !== original){
      row.entidade = abbreviated;
    }
    row._search = buildSearchIndex(row);
  }
}

/* ==============================
   Estado + elementos
================================*/
function initDashboard(root, storageKey){
  let DATA = [];
  let META = { fonte:"—", atualizado:"—" };
  let PREV_DATA = [];
  let PREV_META = { fonte:"—", atualizado:"—" };
  let SELECTED_FICHAS = new Set();
  let SELECTED_ENTIDADES = new Set();
  let SELECTED_FONTES = new Set();
  let SELECTED_MESES = new Set(MONTHS.map(m => m.key));
  const SORT_STATE = { key: null, dir: "asc" };
  const shouldAbbrevEntidade = root.dataset.tab === "1";

  const els = {
    municipio: root.querySelector("#municipio"),
    ano: root.querySelector("#ano"),
    anoAnterior: root.querySelector("#anoAnterior"),
    fileInput: root.querySelector("#fileInput"),
    fileInputPrev: root.querySelector("#fileInputPrev"),
    btnProcessar: root.querySelector("#btnProcessar"),
    btnLimpar: root.querySelector("#btnLimpar"),
    mesFoco: root.querySelector("#mesFoco"),
    mesVisualizacao: root.querySelector("#mesVisualizacao"),
    dimensao: root.querySelector("#dimensao"),
    tipoSerie: root.querySelector("#tipoSerie"),
    quickSearch: root.querySelector("#quickSearch"),
    entidadeFilter: root.querySelector("#entidadeFilter"),
    fonteFilter: root.querySelector("#fonteFilter"),
    btnLimparFichas: root.querySelector("#btnLimparFichas"),
    fichaChips: root.querySelector("#fichaChips"),
    pillStatus: root.querySelector("#pillStatus"),
    titulo: root.querySelector("#titulo"),
    subtitulo: root.querySelector("#subtitulo"),
    statusArquivo: root.querySelector("#statusArquivo"),
    statusArquivoAnterior: root.querySelector("#statusArquivoAnterior"),
    statusAtualizacao: root.querySelector("#statusAtualizacao"),
    errorBox: root.querySelector("#errorBox"),
    miniPeriodo: root.querySelector("#miniPeriodo"),
    miniDim: root.querySelector("#miniDim"),
    kpiOrcado: root.querySelector("#kpiOrcado"),
    kpiOrcadoObs: root.querySelector("#kpiOrcadoObs"),
    kpiArrecAno: root.querySelector("#kpiArrecAno"),
    kpiArrecAnoObs: root.querySelector("#kpiArrecAnoObs"),
    kpiExec: root.querySelector("#kpiExec"),
    kpiExecObs: root.querySelector("#kpiExecObs"),
    kpiMes: root.querySelector("#kpiMes"),
    kpiMesObs: root.querySelector("#kpiMesObs"),
    kpiVar: root.querySelector("#kpiVar"),
    kpiVarObs: root.querySelector("#kpiVarObs"),
    thMesFoco: root.querySelector("#thMesFoco"),
    tbody: root.querySelector("#tbody"),
    miniLinhas: root.querySelector("#miniLinhas"),
    tableSearch: root.querySelector("#tableSearch"),
    selectAllFiltered: root.querySelector("#selectAllFiltered"),
    btnExportCSV: root.querySelector("#btnExportCSV"),
    bTipo: root.querySelector("#bTipo"),
    bMetrica: root.querySelector("#bMetrica"),
    bEixo: root.querySelector("#bEixo"),
    bAgrupar: root.querySelector("#bAgrupar"),
    legendPrevLabel: root.querySelector("#legendPrevLabel"),
    legendPrevItem: root.querySelector('[data-series-label="prev"]'),
    legendPrevInput: root.querySelector('input[data-series="prev"]'),
  };

  const chartSerieState = {
    points: [],
    labels: [],
    values: [],
    avgValue: 0,
    visibility: {
      total: true,
      avg: true,
      prev: true,
    },
  };
  let chartSerieTooltip = null;
  const chartTopState = {
    rows: [],
  };
  let chartTopTooltip = null;
  const tableSortButtons = Array.from(root.querySelectorAll(".sortBtn"));
  const serieLegendInputs = Array.from(root.querySelectorAll(".chartLegend input[data-series]"));

  function showError(msg){
    els.errorBox.style.display = msg ? "block" : "none";
    els.errorBox.textContent = msg || "";
  }
  function clearError(){ showError(""); }

  function updateSortButtons(){
    for (const btn of tableSortButtons){
      const key = btn.dataset.sort;
      const isActive = SORT_STATE.key === key;
      btn.classList.toggle("active", isActive);
      if (!isActive){
        btn.textContent = "⇅";
        btn.setAttribute("aria-pressed", "false");
        continue;
      }
      btn.setAttribute("aria-pressed", "true");
      btn.textContent = SORT_STATE.dir === "asc" ? "↑" : "↓";
    }
  }

  function toggleSort(key){
    if (SORT_STATE.key !== key){
      SORT_STATE.key = key;
      SORT_STATE.dir = "asc";
    } else if (SORT_STATE.dir === "asc"){
      SORT_STATE.dir = "desc";
    } else {
      SORT_STATE.key = null;
      SORT_STATE.dir = "asc";
    }
    updateSortButtons();
    updateUI();
  }

  (function init(){
    for (const m of MONTHS){
      const opt = document.createElement("option");
      opt.value = m.key;
      opt.textContent = m.label;
      els.mesFoco.appendChild(opt);
    }
    els.mesFoco.value = "janeiro";
    if (els.mesVisualizacao){
      for (const m of MONTHS){
        const opt = document.createElement("option");
        opt.value = m.key;
        opt.textContent = m.label;
        opt.selected = true;
        els.mesVisualizacao.appendChild(opt);
      }
    }

    const saved = localStorage.getItem(storageKey);
    if (saved){
      try{
        const obj = JSON.parse(saved);
        DATA = obj.data || [];
        if (shouldAbbrevEntidade) applyEntidadeAbbreviations(DATA);
        META = obj.meta || META;
        PREV_DATA = obj.prevData || [];
        if (shouldAbbrevEntidade) applyEntidadeAbbreviations(PREV_DATA);
        PREV_META = obj.prevMeta || PREV_META;
        SELECTED_FICHAS = new Set(obj.selectedFichas || []);
        SELECTED_ENTIDADES = new Set(obj.selectedEntidades || []);
        SELECTED_FONTES = new Set(obj.selectedFontes || []);
        SELECTED_MESES = new Set(obj.selectedMeses || MONTHS.map(m => m.key));
        els.municipio.value = obj.municipio || "";
        els.ano.value = obj.ano || "";
        els.anoAnterior.value = obj.anoAnterior || "";
        els.mesFoco.value = obj.mesFoco || "janeiro";
        els.dimensao.value = obj.dimensao || "natureza";
        els.tipoSerie.value = obj.tipoSerie || "line";
        els.bTipo.value = obj.bTipo || "bar";
        els.bMetrica.value = obj.bMetrica || "mes";
        els.bEixo.value = obj.bEixo || "dim";
        els.bAgrupar.value = obj.bAgrupar || "none";
        if (obj.serieVisibility){
          chartSerieState.visibility = { ...chartSerieState.visibility, ...obj.serieVisibility };
        }
      }catch(e){}
    }
    if (els.mesVisualizacao){
      const allowed = new Set(MONTHS.map(m => m.key));
      SELECTED_MESES = new Set(Array.from(SELECTED_MESES).filter(m => allowed.has(m)));
      if (!SELECTED_MESES.size){
        SELECTED_MESES = new Set(MONTHS.map(m => m.key));
      }
      for (const opt of els.mesVisualizacao.options){
        opt.selected = SELECTED_MESES.has(opt.value);
      }
    }

    mountCanvas("chartSerie");
    mountCanvas("chartTop");
    mountCanvas("chartBuilder");
    setupChartSerieTooltip();
    setupChartTopTooltip();
    setupChartTopSelection();

    syncSerieLegend();
    updateSortButtons();
    updateUI();
    window.addEventListener("resize", ()=>updateUI());
  })();

  function saveState(){
    const obj = {
      data: DATA,
      meta: META,
      prevData: PREV_DATA,
      prevMeta: PREV_META,
      selectedFichas: Array.from(SELECTED_FICHAS),
      selectedEntidades: Array.from(SELECTED_ENTIDADES),
      selectedFontes: Array.from(SELECTED_FONTES),
      selectedMeses: Array.from(SELECTED_MESES),
      municipio: els.municipio.value,
      ano: els.ano.value,
      anoAnterior: els.anoAnterior.value,
      mesFoco: els.mesFoco.value,
      dimensao: els.dimensao.value,
      tipoSerie: els.tipoSerie.value,
      bTipo: els.bTipo.value,
      bMetrica: els.bMetrica.value,
      bEixo: els.bEixo.value,
      bAgrupar: els.bAgrupar.value,
      serieVisibility: chartSerieState.visibility,
    };
    localStorage.setItem(storageKey, JSON.stringify(obj));
  }

  /* ==============================
     Cálculos
  ================================*/
  function sumMonth(row, mesKey){ return row.values?.[mesKey] || 0; }
  function sumAcum(row, mesKey){
    const idx = MONTHS.findIndex(m => m.key === mesKey);
    if (idx < 0) return 0;
    let s = 0;
    for (let i=0;i<=idx;i++) s += row.values[MONTHS[i].key] || 0;
    return s;
  }
  function totalByMonth(rows){
    const totals = {};
    for (const m of MONTHS) totals[m.key] = 0;
    for (const r of rows){
      for (const m of MONTHS) totals[m.key] += (r.values[m.key] || 0);
    }
    return totals;
  }
  function totalForMonths(rows, months){
    const totals = totalByMonth(rows);
    return months.reduce((acc, month) => acc + (totals[month.key] || 0), 0);
  }
  function groupSum(rows, dimKey, mesKey, mode){
    const map = new Map();
    for (const r of rows){
      const dimVal = (r[dimKey] || "—").toString().trim() || "—";
      let val = 0;
      if (mode === "mes") val = sumMonth(r, mesKey);
      else if (mode === "acum") val = sumAcum(r, mesKey);
      else if (mode === "orc") val = r.orcado || 0;
      else if (mode === "exec"){
        const acum = sumAcum(r, mesKey);
        const orc = r.orcado || 0;
        val = (orc > 0) ? (acum / orc) * 100 : 0;
      }
      map.set(dimVal, (map.get(dimVal) || 0) + val);
    }
    return Array.from(map.entries()).map(([k,v]) => ({k,v}));
  }

  function getChartRows(rows){
    let chartRows = rows.slice();
    chartRows = applyMultiFilters(chartRows);
    if (SELECTED_FICHAS.size){
      chartRows = chartRows.filter(r => SELECTED_FICHAS.has(r.ficha));
    }
    return chartRows;
  }

  function applyFilters(){
    const mesKey = els.mesFoco.value;
    const quick = normalizeText(els.quickSearch.value || "");
    const tableQ = normalizeText(els.tableSearch.value || "");
    const q = quick || tableQ;

    const chartRows = getChartRows(DATA);

    let tableRows = DATA.slice();
    tableRows = applyMultiFilters(tableRows);
    if (q) tableRows = tableRows.filter(r => matchesTableQuery(r, q));

    return { chartRows, tableRows, mesKey };
  }

  function filterTableRows(rows){
    const q = normalizeText(els.tableSearch.value || "");
    return q ? rows.filter(r => matchesTableQuery(r, q)) : rows;
  }

  function applyMultiFilters(rows){
    let out = rows;
    if (SELECTED_ENTIDADES.size){
      out = out.filter(r => SELECTED_ENTIDADES.has((r.entidade || "").toString().trim()));
    }
    if (SELECTED_FONTES.size){
      const normalizedSelected = new Set(
        Array.from(SELECTED_FONTES)
          .map(value => normalizeFonteRecursoValue(value))
          .filter(Boolean)
      );
      out = out.filter(r => normalizedSelected.has(normalizeFonteRecursoValue(r.fonteRecurso)));
    }
    return out;
  }

  function collectUniqueValues(rows, key){
    const set = new Set();
    for (const r of rows){
      const v = (r[key] || "").toString().trim();
      if (v) set.add(v);
    }
    return Array.from(set).sort((a,b)=>a.localeCompare(b, "pt-BR", {numeric:true, sensitivity:"base"}));
  }

  function formatFonteRecursoLabel(value){
    const normalized = normalizeFonteRecursoValue(value);
    if (!normalized) return value;
    if (!/^\d{1}\.\d{3}$/.test(normalized)){
      return normalized;
    }

    const isRecursoProprio = normalized === "1.500" || normalized === "1.501";
    const tipo = isRecursoProprio ? "Recurso Próprio" : "Recurso Vinculado";
    return `${normalized} (${tipo})`;
  }

  function getSelectedValues(selectEl){
    return Array.from(selectEl.selectedOptions || []).map(opt => opt.value).filter(Boolean);
  }

  function syncMultiSelect(selectEl, values, selectedSet, emptyLabel, displayFormatter){
    const allowed = new Set(values);
    const nextSelected = new Set(Array.from(selectedSet).filter(v => allowed.has(v)));
    selectEl.innerHTML = "";

    if (!values.length){
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = emptyLabel;
      opt.disabled = true;
      opt.selected = true;
      selectEl.appendChild(opt);
      selectedSet.clear();
      return;
    }

    for (const v of values){
      const opt = document.createElement("option");
      opt.value = v;
      opt.textContent = displayFormatter ? displayFormatter(v) : v;
      if (nextSelected.has(v)) opt.selected = true;
      selectEl.appendChild(opt);
    }

    selectedSet.clear();
    for (const v of nextSelected) selectedSet.add(v);
  }

  function syncFilterOptions(){
    const entidades = collectUniqueValues(DATA, "entidade");
    const fontes = collectUniqueValues(DATA, "fonteRecurso");
    syncMultiSelect(els.entidadeFilter, entidades, SELECTED_ENTIDADES, "Sem entidades");
    syncMultiSelect(
      els.fonteFilter,
      fontes,
      SELECTED_FONTES,
      "Sem fontes",
      shouldAbbrevEntidade ? formatFonteRecursoLabel : null
    );
  }

  function refreshMultiSelections(){
    if (els.entidadeFilter.options.length && !els.entidadeFilter.options[0].disabled){
      SELECTED_ENTIDADES = new Set(getSelectedValues(els.entidadeFilter));
    }
    if (els.fonteFilter.options.length && !els.fonteFilter.options[0].disabled){
      SELECTED_FONTES = new Set(getSelectedValues(els.fonteFilter));
    }
  }

  function refreshMonthSelections(){
    if (!els.mesVisualizacao) return;
    const selected = getSelectedValues(els.mesVisualizacao);
    if (selected.length){
      SELECTED_MESES = new Set(selected);
    } else {
      SELECTED_MESES = new Set(MONTHS.map(m => m.key));
      for (const opt of els.mesVisualizacao.options){
        opt.selected = true;
      }
    }
  }

  function getVisibleMonths(){
    const selected = Array.from(SELECTED_MESES);
    const allowed = new Set(MONTHS.map(m => m.key));
    const filtered = selected.filter(m => allowed.has(m));
    if (!filtered.length) return MONTHS.slice();
    return MONTHS.filter(m => filtered.includes(m.key));
  }

  function updateMiniPeriodo(visibleMonths){
    if (!els.miniPeriodo) return;
    if (!visibleMonths.length || visibleMonths.length === MONTHS.length){
      els.miniPeriodo.textContent = "jan..dez";
      return;
    }
    if (visibleMonths.length === 1){
      els.miniPeriodo.textContent = visibleMonths[0].label;
      return;
    }
    els.miniPeriodo.textContent = `${visibleMonths.length} meses selecionados`;
  }

  function toggleFichaSelection(ficha){
    if (!ficha) return;
    if (SELECTED_FICHAS.has(ficha)) SELECTED_FICHAS.delete(ficha);
    else SELECTED_FICHAS.add(ficha);
    updateUI();
  }

  function clearFichaSelection(){
    if (!SELECTED_FICHAS.size) return;
    SELECTED_FICHAS.clear();
    updateUI();
  }

  function syncSerieLegend(){
    serieLegendInputs.forEach(input => {
      const series = input.dataset.series;
      const isVisible = chartSerieState.visibility[series] !== false;
      input.checked = isVisible;
      const label = input.closest(".legendItem");
      if (label) label.classList.toggle("is-off", !isVisible);
    });
  }

  function getPrevLabel(){
    const manual = (els.anoAnterior?.value || "").trim();
    if (manual) return manual;
    const anoAtual = parseInt((els.ano?.value || "").trim(), 10);
    if (!Number.isNaN(anoAtual)) return String(anoAtual - 1);
    return "Ano anterior";
  }
  function getCurrentLabel(){
    const manual = (els.ano?.value || "").trim();
    if (manual) return manual;
    return "Ano atual";
  }

  function syncPrevLegend(){
    if (!els.legendPrevItem) return;
    const hasPrev = PREV_DATA.length > 0;
    els.legendPrevItem.style.display = hasPrev ? "inline-flex" : "none";
    if (!hasPrev){
      chartSerieState.visibility.prev = false;
    }
    if (els.legendPrevLabel){
      els.legendPrevLabel.textContent = getPrevLabel();
    }
  }

  function renderFichaChips(){
    const container = els.fichaChips;
    container.innerHTML = "";
    if (!SELECTED_FICHAS.size){
      const empty = document.createElement("div");
      empty.className = "hint";
      empty.style.margin = "0";
      empty.textContent = "Nenhuma ficha selecionada.";
      container.appendChild(empty);
      return;
    }

    const frag = document.createDocumentFragment();
    for (const ficha of Array.from(SELECTED_FICHAS)){
      const chip = document.createElement("div");
      chip.className = "chip";
      chip.textContent = ficha;

      const btn = document.createElement("button");
      btn.type = "button";
      btn.setAttribute("aria-label", `Remover ficha ${ficha}`);
      btn.textContent = "×";
      btn.addEventListener("click", () => {
        SELECTED_FICHAS.delete(ficha);
        updateUI();
      });

      chip.appendChild(btn);
      frag.appendChild(chip);
    }
    container.appendChild(frag);
  }

  /* ==============================
     Charts (Canvas)
  ================================*/
  function mountCanvas(containerId){
    const el = root.querySelector(`#${containerId}`);
    el.innerHTML = "";
    const c = document.createElement("canvas");
    c.className = "chartCanvas";
    c.dataset.role = "chart";
    el.appendChild(c);
  }
  function getCanvas(containerId){
    const el = root.querySelector(`#${containerId}`);
    return el.querySelector("canvas[data-role='chart']");
  }
  function fitCanvas(canvas){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(300, Math.floor(rect.width));
    const h = Math.max(220, Math.floor(rect.height));
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return {ctx, w, h};
  }
  function clearChart(ctx, w, h){
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "rgba(0,0,0,.08)";
    ctx.fillRect(0,0,w,h);
    ctx.strokeStyle = "rgba(255,255,255,.08)";
    ctx.strokeRect(0.5,0.5,w-1,h-1);
  }
  function drawGrid(ctx, plot, yTicks=4){
    const {x,y,w,h} = plot;
    ctx.strokeStyle = "rgba(255,255,255,.06)";
    ctx.lineWidth = 1;
    for(let i=0;i<=yTicks;i++){
      const yy = y + (h*i)/yTicks;
      ctx.beginPath();
      ctx.moveTo(x, yy);
      ctx.lineTo(x+w, yy);
      ctx.stroke();
    }
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x, y+h);
    ctx.lineTo(x+w, y+h);
    ctx.stroke();
  }
  function formatCompact(n){
    const abs = Math.abs(n);
    if (abs >= 1e9) return (n/1e9).toFixed(1).replace(".",",")+" bi";
    if (abs >= 1e6) return (n/1e6).toFixed(1).replace(".",",")+" mi";
    if (abs >= 1e3) return (n/1e3).toFixed(1).replace(".",",")+" mil";
    return n.toFixed(0).replace(".",",");
  }
  function drawYAxisLabels(ctx, plot, maxY, yTicks=4){
    const {x,y,h} = plot;
    ctx.fillStyle = "rgba(233,238,252,.75)";
    ctx.font = "12px system-ui, Arial";
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    for(let i=0;i<=yTicks;i++){
      const val = maxY*(1 - i/yTicks);
      const yy = y + (h*i)/yTicks;
      ctx.fillText(formatCompact(val), x-8, yy);
    }
  }
  function drawXAxisLabels(ctx, plot, labels){
    const {x,y,w,h} = plot;
    ctx.fillStyle = "rgba(233,238,252,.75)";
    ctx.font = "12px system-ui, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    const n = labels.length;
    const step = w / Math.max(1,n-1);
    for(let i=0;i<n;i++){
      const xx = x + step*i;
      if (n > 12 && i % 2 === 1) continue;
      ctx.save();
      ctx.translate(xx, y+h+8);
      ctx.rotate(-Math.PI/6);
      ctx.fillText(labels[i], 0, 0);
      ctx.restore();
    }
  }
  function drawLineSeries(ctx, plot, values, maxY, options = {}){
    const {x,y,w,h} = plot;
    const n = values.length;
    const step = w / Math.max(1,n-1);

    const {
      color = "rgba(110,231,255,.90)",
      pointColor = color,
      pointRadius = 3,
      lineWidth = 2,
      drawPoints = true,
      dash = [],
    } = options;

    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(dash);
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const v = values[i] || 0;
      const xx = x + step*i;
      const yy = y + h - (maxY ? (v/maxY)*h : 0);
      if (i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    if (drawPoints){
      ctx.fillStyle = pointColor;
      for(let i=0;i<n;i++){
        const v = values[i] || 0;
        const xx = x + step*i;
        const yy = y + h - (maxY ? (v/maxY)*h : 0);
        ctx.beginPath();
        ctx.arc(xx,yy,pointRadius,0,Math.PI*2);
        ctx.fill();
      }
    }
  }
  function drawPointLabels(ctx, plot, values, maxY, options = {}){
    const {x,y,w,h} = plot;
    const n = values.length;
    const step = w / Math.max(1,n-1);
    const {
      color = "rgba(233,238,252,.95)",
      background = "rgba(12,20,43,.85)",
      border = "rgba(255,255,255,.12)",
      offset = -8,
    } = options;

    ctx.font = "11px system-ui, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";

    for(let i=0;i<n;i++){
      const v = values[i] || 0;
      const label = formatCompact(v);
      const xx = x + step*i;
      const yy = y + h - (maxY ? (v/maxY)*h : 0);
      const textW = ctx.measureText(label).width;
      const padX = 6;
      const boxH = 18;
      const boxW = Math.max(28, textW + padX * 2);
      const targetY = yy + offset;
      const boxY = Math.min(Math.max(targetY - boxH, y + 4), y + h - boxH - 4);
      const boxX = xx - boxW / 2;

      ctx.fillStyle = background;
      ctx.fillRect(boxX, boxY, boxW, boxH);
      ctx.strokeStyle = border;
      ctx.strokeRect(boxX, boxY, boxW, boxH);
      ctx.fillStyle = color;
      ctx.fillText(label, xx, boxY + boxH - 4);
    }
  }
  function drawBarSeries(ctx, plot, values, maxY){
    const {x,y,w,h} = plot;
    const n = values.length;
    const gap = 8;
    const bw = Math.max(6, (w / n) - gap);
    ctx.fillStyle = "rgba(139,92,246,.75)";
    for(let i=0;i<n;i++){
      const v = values[i] || 0;
      const barH = maxY ? (v/maxY)*h : 0;
      const xx = x + i*(w/n) + gap/2;
      const yy = y + h - barH;
      ctx.fillRect(xx, yy, bw, barH);
    }
  }
  function buildLinePoints(plot, values, maxY, labels, seriesLabel){
    const {x,y,w,h} = plot;
    const n = values.length;
    const step = w / Math.max(1,n-1);
    const points = [];
    for (let i=0;i<n;i++){
      const v = values[i] || 0;
      const xx = x + step*i;
      const yy = y + h - (maxY ? (v/maxY)*h : 0);
      points.push({x: xx, y: yy, value: v, label: labels[i], series: seriesLabel});
    }
    return points;
  }
  function setupChartSerieTooltip(){
    const container = root.querySelector("#chartSerie");
    if (!container || chartSerieTooltip) return;

    chartSerieTooltip = document.createElement("div");
    chartSerieTooltip.className = "chartTooltip";
    container.appendChild(chartSerieTooltip);

    const hideTooltip = () => {
      chartSerieTooltip.classList.remove("visible");
    };

    container.addEventListener("mousemove", (event) => {
      if (!chartSerieState.points.length) return hideTooltip();
      const canvas = getCanvas("chartSerie");
      if (!canvas) return hideTooltip();
      const rect = canvas.getBoundingClientRect();
      const mx = event.clientX - rect.left;
      const my = event.clientY - rect.top;
      const radius = 8;
      let hit = null;
      let best = Infinity;
      for (const point of chartSerieState.points){
        const dx = mx - point.x;
        const dy = my - point.y;
        const dist = dx*dx + dy*dy;
        if (dist <= radius*radius && dist < best){
          best = dist;
          hit = point;
        }
      }
      if (!hit) return hideTooltip();
      const prefix = hit.series === "Média" ? "Média simples" : hit.series;
      chartSerieTooltip.textContent = `${hit.label} • ${prefix}: ${moneyBR(hit.value)}`;
      chartSerieTooltip.style.left = `${hit.x}px`;
      chartSerieTooltip.style.top = `${hit.y}px`;
      chartSerieTooltip.classList.add("visible");
    });

    container.addEventListener("mouseleave", hideTooltip);
  }
  function setupChartTopTooltip(){
    const container = root.querySelector("#chartTop");
    if (!container || chartTopTooltip) return;

    chartTopTooltip = document.createElement("div");
    chartTopTooltip.className = "chartTooltip";
    container.appendChild(chartTopTooltip);

    const hideTooltip = () => {
      chartTopTooltip.classList.remove("visible");
    };

    container.addEventListener("mousemove", (event) => {
      if (!chartTopState.rows.length) return hideTooltip();
      const canvas = getCanvas("chartTop");
      if (!canvas) return hideTooltip();
      const rect = canvas.getBoundingClientRect();
      const mx = event.clientX - rect.left;
      const my = event.clientY - rect.top;
      const hit = chartTopState.rows.find(row => (
        row.isTrimmed &&
        mx >= row.labelRect.x &&
        mx <= row.labelRect.x + row.labelRect.w &&
        my >= row.labelRect.y &&
        my <= row.labelRect.y + row.labelRect.h
      ));
      if (!hit) return hideTooltip();
      chartTopTooltip.textContent = hit.label;
      chartTopTooltip.style.left = `${mx}px`;
      chartTopTooltip.style.top = `${hit.y + hit.h / 2}px`;
      chartTopTooltip.classList.add("visible");
    });

    container.addEventListener("mouseleave", hideTooltip);
  }
  function setupChartTopSelection(){
    const container = root.querySelector("#chartTop");
    if (!container) return;

    container.addEventListener("click", (event) => {
      if (els.dimensao.value !== "ficha") return;
      const canvas = getCanvas("chartTop");
      if (!canvas) return;
      const rect = canvas.getBoundingClientRect();
      const mx = event.clientX - rect.left;
      const my = event.clientY - rect.top;
      const hit = chartTopState.rows.find(row => {
        const inLabel =
          mx >= row.labelRect.x &&
          mx <= row.labelRect.x + row.labelRect.w &&
          my >= row.labelRect.y &&
          my <= row.labelRect.y + row.labelRect.h;
        const inBar =
          mx >= row.barRect.x &&
          mx <= row.barRect.x + row.barRect.w &&
          my >= row.barRect.y &&
          my <= row.barRect.y + row.barRect.h;
        return inLabel || inBar;
      });
      if (!hit) return;
      toggleFichaSelection(hit.label);
    });
  }
  function drawHBar(ctx, plot, labels, values){
    const {x,y,w,h} = plot;
    const n = labels.length;
    const max = Math.max(...values, 1);
    const rowH = h / n;
    ctx.font = "12px system-ui, Arial";
    ctx.textBaseline = "middle";
    const rows = [];

    for(let i=0;i<n;i++){
      const v = values[i] || 0;
      const barW = (v/max) * (w*0.62);
      const yy = y + i*rowH + rowH/2;

      ctx.fillStyle = "rgba(233,238,252,.80)";
      ctx.textAlign = "left";
      const name = (labels[i] || "").toString();
      const isTrimmed = name.length > 20;
      const trimmed = isTrimmed ? name.slice(0,20)+"…" : name;
      ctx.fillText(trimmed, x, yy);
      const textW = ctx.measureText(trimmed).width;
      rows.push({
        label: name,
        isTrimmed,
        labelRect: {
          x,
          y: yy - rowH / 2,
          w: textW,
          h: rowH,
        },
      });

      const bx = x + w*0.34;
      ctx.fillStyle = "rgba(110,231,255,.60)";
      ctx.fillRect(bx, yy-6, barW, 12);
      rows[rows.length - 1].barRect = {x: bx, y: yy - 6, w: barW, h: 12};

      ctx.fillStyle = "rgba(233,238,252,.70)";
      ctx.textAlign = "right";
      ctx.fillText(formatCompact(v), x+w, yy);
    }
    return rows;
  }

  function renderSerie(rows, prevRows, visibleMonths){
    const canvas = getCanvas("chartSerie");
    const {ctx,w,h} = fitCanvas(canvas);
    clearChart(ctx,w,h);

    const months = (visibleMonths && visibleMonths.length) ? visibleMonths : MONTHS;
    const showYearBars = root.dataset.tab === "1" && months.length < MONTHS.length;
    const totals = totalByMonth(rows);
    const labels = showYearBars
      ? [getCurrentLabel(), ...(prevRows.length ? [getPrevLabel()] : [])]
      : months.map(m=>m.label);
    const values = showYearBars
      ? [
          totalForMonths(rows, months),
          ...(prevRows.length ? [totalForMonths(prevRows, months)] : [])
        ]
      : months.map(m=>totals[m.key] || 0);
    const avgValue = values.length ? values.reduce((a,v)=>a+v,0) / values.length : 0;
    const avgSeries = values.map(() => avgValue);
    const hasPrev = prevRows.length > 0;
    const prevTotals = hasPrev ? totalByMonth(prevRows) : {};
    const prevValues = hasPrev ? months.map(m=>prevTotals[m.key] || 0) : [];
    const maxY = showYearBars
      ? Math.max(...values, 1)
      : Math.max(...values, avgValue, ...(hasPrev ? prevValues : []), 1);

    const plot = {x:60, y:16, w:w-80, h:h-70};
    drawGrid(ctx, plot, 4);
    drawYAxisLabels(ctx, plot, maxY, 4);
    drawXAxisLabels(ctx, plot, labels);

    const showTotal = chartSerieState.visibility.total !== false;
    const showAvg = chartSerieState.visibility.avg !== false;
    const showPrev = chartSerieState.visibility.prev !== false && hasPrev;

    const prevDash = root.dataset.tab === "1" ? [] : [3,4];
    const emphasizePoints = root.dataset.tab === "1";
    if (showYearBars || els.tipoSerie.value === "bar"){
      if (showTotal) drawBarSeries(ctx, plot, values, maxY);
      if (!showYearBars && showAvg) drawLineSeries(ctx, plot, avgSeries, maxY, {
        color: "rgba(249,115,22,.9)",
        pointColor: "rgba(249,115,22,.95)",
        pointRadius: emphasizePoints ? 3 : 2,
        lineWidth: 2,
        dash: [6,4],
      });
      if (!showYearBars && showPrev) drawLineSeries(ctx, plot, prevValues, maxY, {
        color: "rgba(139,92,246,.9)",
        pointColor: "rgba(139,92,246,.95)",
        pointRadius: emphasizePoints ? 3 : 2,
        lineWidth: emphasizePoints ? 2.5 : 2,
        dash: prevDash,
      });
    } else {
      if (showTotal) drawLineSeries(ctx, plot, values, maxY, {
        color: "rgba(110,231,255,.90)",
        pointColor: "rgba(110,231,255,.95)",
        pointRadius: emphasizePoints ? 4 : 3,
        lineWidth: emphasizePoints ? 2.8 : 2,
      });
      if (showPrev) drawLineSeries(ctx, plot, prevValues, maxY, {
        color: "rgba(139,92,246,.9)",
        pointColor: "rgba(139,92,246,.95)",
        pointRadius: emphasizePoints ? 4 : 3,
        lineWidth: emphasizePoints ? 2.6 : 2,
        dash: prevDash,
      });
      if (showAvg) drawLineSeries(ctx, plot, avgSeries, maxY, {
        color: "rgba(249,115,22,.9)",
        pointColor: "rgba(249,115,22,.95)",
        pointRadius: emphasizePoints ? 3 : 2,
        lineWidth: emphasizePoints ? 2.4 : 2,
        dash: [6,4],
      });
    }

    if (!showYearBars && emphasizePoints && els.tipoSerie.value === "line" && labels.length <= 6){
      if (showTotal) drawPointLabels(ctx, plot, values, maxY, {
        color: "rgba(18,32,54,.95)",
        background: "rgba(110,231,255,.95)",
        border: "rgba(110,231,255,.7)",
        offset: -10,
      });
      if (showPrev) drawPointLabels(ctx, plot, prevValues, maxY, {
        color: "rgba(233,238,252,.95)",
        background: "rgba(139,92,246,.85)",
        border: "rgba(139,92,246,.6)",
        offset: 16,
      });
    }

    chartSerieState.labels = labels;
    chartSerieState.values = values;
    chartSerieState.avgValue = avgValue;
    const nextPoints = [];
    if (!showYearBars && els.tipoSerie.value === "line" && showTotal){
      nextPoints.push(...buildLinePoints(plot, values, maxY, labels, "Total"));
    }
    if (!showYearBars && showPrev){
      nextPoints.push(...buildLinePoints(plot, prevValues, maxY, labels, getPrevLabel()));
    }
    if (!showYearBars && showAvg){
      nextPoints.push(...buildLinePoints(plot, avgSeries, maxY, labels, "Média"));
    }
    chartSerieState.points = nextPoints;
  }

  function renderTop(rows, mesKey){
    const canvas = getCanvas("chartTop");
    const {ctx,w,h} = fitCanvas(canvas);
    clearChart(ctx,w,h);

    const dim = els.dimensao.value;
    els.miniDim.textContent = dim === "natureza"
      ? "Natureza"
      : dim === "ficha"
        ? "Ficha"
        : dim === "nome"
          ? "Nome"
          : dim === "entidade"
            ? "Entidade"
            : "Fonte de recurso";
    canvas.classList.toggle("chartClickable", dim === "ficha");

    const grouped = groupSum(rows, dim, mesKey, "acum")
      .sort((a,b)=>b.v-a.v)
      .slice(0,10);

    const labels = grouped.map(d=>d.k);
    const values = grouped.map(d=>d.v);

    const plot = {x:14, y:16, w:w-28, h:h-34};
    chartTopState.rows = drawHBar(ctx, plot, labels, values);
  }

  function renderBuilder(rows, mesKey){
    const canvas = getCanvas("chartBuilder");
    const {ctx,w,h} = fitCanvas(canvas);
    clearChart(ctx,w,h);

    const tipo = els.bTipo.value;
    const metrica = els.bMetrica.value;
    const eixo = els.bEixo.value;
    const agrupar = els.bAgrupar.value;
    const dim = els.dimensao.value;

    const plot = {x:60, y:16, w:w-80, h:h-70};

    let labels = [];
    let series = [];

    if (eixo === "meses"){
      labels = MONTHS.map(m=>m.label);

      const gKey = agrupar === "none" ? null : agrupar;
      if (!gKey){
        const values = MONTHS.map(m => rows.reduce((a,r)=>a+(r.values[m.key]||0),0));
        series = [{name:"Total", values}];
      } else {
        const groups = new Map();
        for (const r of rows){
          const k = (r[gKey]||"—").toString().trim()||"—";
          if (!groups.has(k)) groups.set(k, []);
          groups.get(k).push(r);
        }
        const ranked = Array.from(groups.entries())
          .map(([k,rs]) => ({k, v: rs.reduce((a,r)=>a+sumAcum(r, mesKey),0)}))
          .sort((a,b)=>b.v-a.v)
          .slice(0,6);

        for (const it of ranked){
          const rs = groups.get(it.k);
          const values = MONTHS.map(m => rs.reduce((a,r)=>a+(r.values[m.key]||0),0));
          series.push({name: it.k, values});
        }
      }
    } else {
      const mode = metrica === "mes" ? "mes" : metrica === "acum" ? "acum" : metrica === "orc" ? "orc" : "exec";
      const grouped = groupSum(rows, dim, mesKey, mode).sort((a,b)=>b.v-a.v).slice(0,12);
      labels = grouped.map(d=>d.k);

      if (agrupar === "none"){
        series = [{name:"Total", values: grouped.map(d=>d.v)}];
      } else {
        const gKey = agrupar;
        const groups = new Map();
        for (const r of rows){
          const k = (r[gKey]||"—").toString().trim()||"—";
          if (!groups.has(k)) groups.set(k, []);
          groups.get(k).push(r);
        }
        const ranked = Array.from(groups.entries())
          .map(([k,rs]) => ({k, v: rs.reduce((a,r)=>a+sumAcum(r, mesKey),0)}))
          .sort((a,b)=>b.v-a.v)
          .slice(0,6);

        for (const it of ranked){
          const rs = groups.get(it.k);
          const values = labels.map(labelX => {
            const only = rs.filter(r => ((r[dim]||"—").toString().trim()||"—") === labelX);
            if (metrica === "mes") return only.reduce((a,r)=>a+sumMonth(r, mesKey),0);
            if (metrica === "acum") return only.reduce((a,r)=>a+sumAcum(r, mesKey),0);
            if (metrica === "orc") return only.reduce((a,r)=>a+(r.orcado||0),0);
            const acum = only.reduce((a,r)=>a+sumAcum(r, mesKey),0);
            const orc = only.reduce((a,r)=>a+(r.orcado||0),0);
            return orc>0 ? (acum/orc)*100 : 0;
          });
          series.push({name: it.k, values});
        }
      }
    }

    const allValues = series.flatMap(s => s.values);
    const maxY = Math.max(...allValues, 1);

    drawGrid(ctx, plot, 4);
    drawYAxisLabels(ctx, plot, maxY, 4);
    drawXAxisLabels(ctx, plot, labels);

    if (tipo === "line"){
      drawLineSeries(ctx, plot, series[0]?.values || [], maxY);
    } else if (tipo === "bar"){
      drawBarSeries(ctx, plot, series[0]?.values || [], maxY);
    } else {
      const n = labels.length || 1;
      const gap = 8;
      const bw = Math.max(6, (plot.w / n) - gap);
      const palette = [
        "rgba(110,231,255,.55)",
        "rgba(139,92,246,.50)",
        "rgba(34,197,94,.42)",
        "rgba(251,191,36,.40)",
        "rgba(239,68,68,.35)",
        "rgba(255,255,255,.22)"
      ];
      for (let i=0;i<n;i++){
        let stack = 0;
        for (let s=0;s<Math.min(series.length,6);s++){
          const v = (series[s].values[i] || 0);
          const barH = (v/maxY)*plot.h;
          const xx = plot.x + i*(plot.w/n) + gap/2;
          const yy = plot.y + plot.h - ((stack/maxY)*plot.h) - barH;
          ctx.fillStyle = palette[s % palette.length];
          ctx.fillRect(xx, yy, bw, barH);
          stack += v;
        }
      }
    }
  }

  function renderTable(rows, mesKey){
    const idx = MONTHS.findIndex(m=>m.key===mesKey);
    let sorted = rows.slice();
    if (SORT_STATE.key){
      const key = SORT_STATE.key;
      const dir = SORT_STATE.dir === "asc" ? 1 : -1;
      sorted.sort((a,b)=>{
        const av = (a[key] ?? "").toString();
        const bv = (b[key] ?? "").toString();
        return av.localeCompare(bv, "pt-BR", {numeric:true, sensitivity:"base"}) * dir;
      });
    } else {
      sorted = sorted.sort((a,b)=> (sumMonth(b, mesKey) - sumMonth(a, mesKey)));
    }

    const filtered = filterTableRows(sorted);
    const selectable = filtered.filter(r => (r.ficha ?? "").toString().trim());
    const anySelected = selectable.some(r => SELECTED_FICHAS.has(r.ficha));
    const allSelected = selectable.length && selectable.every(r => SELECTED_FICHAS.has(r.ficha));

    els.miniLinhas.textContent = `${filtered.length} linhas`;
    els.selectAllFiltered.disabled = !selectable.length;
    els.selectAllFiltered.checked = Boolean(allSelected);
    els.selectAllFiltered.indeterminate = Boolean(anySelected && !allSelected);
    els.tbody.innerHTML = "";

    const frag = document.createDocumentFragment();
    for (const r of filtered.slice(0, 900)){
      const tr = document.createElement("tr");
      if (SELECTED_FICHAS.has(r.ficha)) tr.classList.add("selected");
      const acum = sumAcum(r, mesKey);

      const tdFicha = document.createElement("td");
      tdFicha.textContent = r.ficha ?? "";
      tdFicha.dataset.ficha = r.ficha ?? "";
      tdFicha.classList.add("clickSelect");

      const tdNatureza = document.createElement("td");
      tdNatureza.textContent = r.natureza ?? "";

      const tdNome = document.createElement("td");
      tdNome.textContent = r.nome ?? "";
      tdNome.title = r.nome ?? "";
      tdNome.dataset.nome = r.nome ?? "";
      tdNome.classList.add("clickFilter");

      const tdOrcado = document.createElement("td");
      tdOrcado.textContent = moneyBR(r.orcado);

      const tdMes = document.createElement("td");
      tdMes.textContent = moneyBR(sumMonth(r, mesKey));

      const tdAcum = document.createElement("td");
      tdAcum.textContent = moneyBR(acum);

      tr.append(tdFicha, tdNatureza, tdNome, tdOrcado, tdMes, tdAcum);
      frag.appendChild(tr);
    }
    els.tbody.appendChild(frag);
    els.thMesFoco.textContent = MONTHS[idx]?.label || "Mês";
  }

  function updateHeader(){
    const muni = els.municipio.value.trim();
    const ano = els.ano.value.trim();
    els.titulo.textContent = muni ? `Dashboard de Receitas — ${muni}` : "Dashboard de Receitas";
    els.subtitulo.textContent = ano ? `Visão gerencial (${ano}) com filtros e análises dinâmicas.` : "Visão gerencial com filtros e análises dinâmicas.";
    const prevFonte = PREV_DATA.length ? PREV_META.fonte : "—";
    els.statusArquivo.textContent = `Fonte: ${META.fonte || "—"}`;
    els.statusArquivoAnterior.textContent = `Ano anterior: ${prevFonte || "—"}`;
    els.statusAtualizacao.textContent = `Atualização: ${META.atualizado || "—"}`;
  }

  function updateKPIs(rows, mesKey){
    const totalOrcado = rows.reduce((a,r)=>a+(r.orcado||0),0);
    const totals = totalByMonth(rows);

    const idx = MONTHS.findIndex(m => m.key === mesKey);
    const mesAtual = totals[mesKey] || 0;

    let acum = 0;
    for (let i=0;i<=idx;i++) acum += totals[MONTHS[i].key] || 0;

    const exec = totalOrcado > 0 ? (acum/totalOrcado)*100 : 0;

    const prevKey = idx > 0 ? MONTHS[idx-1].key : null;
    const prevVal = prevKey ? (totals[prevKey]||0) : 0;

    let varPct = null;
    if (prevKey){
      varPct = prevVal !== 0 ? ((mesAtual - prevVal)/prevVal)*100 : (mesAtual !== 0 ? 100 : 0);
    }

    els.kpiOrcado.textContent = moneyBR(totalOrcado);
    els.kpiOrcadoObs.textContent = "Base: soma do Orçado (filtros aplicados)";

    els.kpiArrecAno.textContent = moneyBR(acum);
    els.kpiArrecAnoObs.textContent = `Acumulado até ${MONTHS[idx]?.label || ""}`;

    els.kpiExec.textContent = pctBR(exec);
    els.kpiExecObs.textContent = (exec >= 90 ? "Execução alta" : exec >= 60 ? "Execução moderada" : "Execução baixa");

    els.kpiMes.textContent = moneyBR(mesAtual);
    els.kpiMesObs.textContent = `Total em ${MONTHS[idx]?.label || ""}`;

    if (varPct === null){
      els.kpiVar.textContent = "—";
      els.kpiVarObs.textContent = "Sem mês anterior";
    } else {
      const arrow = varPct >= 0 ? "▲" : "▼";
      const color = varPct >= 0 ? "var(--good)" : "var(--bad)";
      els.kpiVar.innerHTML = `<span style="color:${color}; font-weight:800;">${arrow} ${pctBR(Math.abs(varPct))}</span>`;
      els.kpiVarObs.textContent = `Comparado a ${MONTHS[idx-1]?.label || ""}`;
    }

  }

  function updateUI(){
    clearError();
    updateHeader();

    refreshMultiSelections();
    refreshMonthSelections();
    syncFilterOptions();

    const { chartRows, tableRows, mesKey } = applyFilters();
    const prevChartRows = getChartRows(PREV_DATA);
    const prevInfo = PREV_DATA.length ? ` • Ano anterior: ${PREV_DATA.length} linhas` : "";
    els.pillStatus.textContent = DATA.length ? `Base carregada • ${DATA.length} linhas${prevInfo}` : "Nenhum arquivo carregado";

    renderFichaChips();
    syncPrevLegend();
    syncSerieLegend();

    updateKPIs(chartRows, mesKey);
    const visibleMonths = getVisibleMonths();
    updateMiniPeriodo(visibleMonths);
    renderSerie(chartRows, prevChartRows, visibleMonths);
    renderTop(chartRows, mesKey);
    renderBuilder(chartRows, mesKey);
    renderTable(tableRows, mesKey);

    saveState();
  }

  async function loadCsvFile(file){
    const buf = await file.arrayBuffer();
    let text = new TextDecoder("utf-8").decode(buf);
    if ((text.match(/�/g) || []).length > 5){
      text = new TextDecoder("iso-8859-1").decode(buf);
    }

    const parsed = parseCSV(text);
    const {objs} = toObjects(parsed.rows);

    if (!objs.length){
      throw new Error("CSV sem dados (apenas cabeçalho ou arquivo vazio).");
    }

    const data = normalizeDataset(objs);
    if (shouldAbbrevEntidade) applyEntidadeAbbreviations(data);

    return {
      data,
      meta: {
        fonte: `${file.name} • CSV (${parsed.sep === ";" ? "separador ;" : "separador ,"} )`,
        atualizado: new Date().toLocaleString("pt-BR"),
      },
    };
  }

  /* ==============================
     Eventos
  ================================*/
  els.btnProcessar.addEventListener("click", async ()=>{
    const file = els.fileInput.files?.[0];
    if (!file){
      showError("Selecione um arquivo CSV antes de carregar.");
      return;
    }

    try{
      els.pillStatus.textContent = "Processando CSV...";
      const result = await loadCsvFile(file);
      DATA = result.data;
      META = result.meta;

      const prevFile = els.fileInputPrev.files?.[0];
      if (prevFile){
        const prevResult = await loadCsvFile(prevFile);
        PREV_DATA = prevResult.data;
        PREV_META = prevResult.meta;
        chartSerieState.visibility.prev = true;
      } else {
        PREV_DATA = [];
        PREV_META = { fonte:"—", atualizado:"—" };
        chartSerieState.visibility.prev = false;
      }

      updateUI();
    }catch(err){
      console.error(err);
      showError("Erro ao processar:\n\n" + (err?.message || err));
      els.pillStatus.textContent = "Erro ao processar";
    }
  });

  els.btnLimpar.addEventListener("click", ()=>{
    if (!confirm("Tem certeza que deseja limpar os dados salvos?")) return;
    DATA = [];
    META = { fonte:"—", atualizado:"—" };
    PREV_DATA = [];
    PREV_META = { fonte:"—", atualizado:"—" };
    SELECTED_FICHAS.clear();
    SELECTED_ENTIDADES.clear();
    SELECTED_FONTES.clear();
    localStorage.removeItem(storageKey);
    els.fileInput.value = "";
    els.fileInputPrev.value = "";
    updateUI();
  });

  [
    els.municipio, els.ano, els.anoAnterior, els.mesFoco, els.dimensao, els.tipoSerie,
    els.quickSearch, els.tableSearch, els.bTipo, els.bMetrica, els.bEixo, els.bAgrupar
  ].forEach(el => el.addEventListener("input", updateUI));

  [els.entidadeFilter, els.fonteFilter, els.mesVisualizacao]
    .filter(Boolean)
    .forEach(el => el.addEventListener("change", updateUI));

  tableSortButtons.forEach(btn => {
    btn.addEventListener("click", () => toggleSort(btn.dataset.sort));
  });

  serieLegendInputs.forEach(input => {
    input.addEventListener("change", () => {
      const series = input.dataset.series;
      chartSerieState.visibility[series] = input.checked;
      syncSerieLegend();
      updateUI();
    });
  });

  els.selectAllFiltered.addEventListener("change", ()=>{
    const { tableRows } = applyFilters();
    const filtered = filterTableRows(tableRows);
    const selectable = filtered.filter(r => (r.ficha ?? "").toString().trim());
    if (els.selectAllFiltered.checked){
      for (const r of selectable) SELECTED_FICHAS.add(r.ficha);
    } else {
      for (const r of selectable) SELECTED_FICHAS.delete(r.ficha);
    }
    updateUI();
  });

  els.quickSearch.addEventListener("input", ()=>{
    els.tableSearch.value = els.quickSearch.value;
    updateUI();
  });

  els.tbody.addEventListener("click", (event)=>{
    const selectTarget = event.target.closest(".clickSelect");
    if (selectTarget && els.tbody.contains(selectTarget)){
      const ficha = selectTarget.dataset.ficha || selectTarget.textContent;
      toggleFichaSelection((ficha || "").toString().trim());
      return;
    }

    const target = event.target.closest(".clickFilter");
    if (!target || !els.tbody.contains(target)) return;
    const nome = target.dataset.nome || target.textContent;
    if (!nome) return;
    els.quickSearch.value = nome;
    els.tableSearch.value = nome;
    els.quickSearch.focus();
    els.quickSearch.select();
    updateUI();
  });

  els.btnLimparFichas.addEventListener("click", clearFichaSelection);

  els.btnExportCSV.addEventListener("click", ()=>{
    if (!DATA.length){
      showError("Carregue um arquivo antes.");
      return;
    }
    clearError();
    const { tableRows, mesKey } = applyFilters();
    const idx = MONTHS.findIndex(m=>m.key===mesKey);
    const mesLabel = MONTHS[idx]?.label || "Mes";

    const header = ["Ficha","Natureza","Nome","Orcado", mesLabel, "Acumulado"];
    const lines = [header.join(";")];

    for (const r of tableRows){
      const acum = sumAcum(r, mesKey);
      const line = [
        (r.ficha||"").replaceAll(";"," "),
        (r.natureza||"").replaceAll(";"," "),
        (r.nome||"").replaceAll(";"," "),
        (r.orcado||0).toString().replace(".",","),
        (sumMonth(r, mesKey)||0).toString().replace(".",","),
        (acum||0).toString().replace(".",","),
      ].join(";");
      lines.push(line);
    }

    const blob = new Blob([lines.join("\n")], {type:"text/csv;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "visao_receitas_export.csv";
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
  });
}

const tabPanels = Array.from(document.querySelectorAll(".tabPanel"));
tabPanels.forEach((panel, index) => {
  if (panel.dataset.tab !== "1") return;
  initDashboard(panel, `receitas_dashboard_offline_v2_tab${index + 1}`);
});

function initExpenses(panel){
  const els = {
    file1: panel.querySelector("#expenseFile1"),
    file2: panel.querySelector("#expenseFile2"),
    file3: panel.querySelector("#expenseFile3"),
    year1: panel.querySelector("#expenseYear1"),
    year2: panel.querySelector("#expenseYear2"),
    year3: panel.querySelector("#expenseYear3"),
    loadBtn: panel.querySelector("#expenseLoadBtn"),
    status: panel.querySelector("#expenseStatus"),
    error: panel.querySelector("#expenseError"),
    chart: panel.querySelector("#expenseChart"),
    legend: panel.querySelector("#expenseLegend"),
    elementChart: panel.querySelector("#expenseElementChart"),
    elementLegend: panel.querySelector("#expenseElementLegend"),
    elementSummary: panel.querySelector("#expenseElementSummary"),
    elementTooltip: panel.querySelector("#expenseElementTooltip"),
    elementSearch: panel.querySelector("#expenseElementSearch"),
    elementSelectAll: panel.querySelector("#expenseElementSelectAll"),
    elementRemoveZero: panel.querySelector("#expenseElementRemoveZero"),
    elementClear: panel.querySelector("#expenseElementClear"),
    elementOptions: panel.querySelector("#expenseElementOptions"),
    elementEmpty: panel.querySelector("#expenseElementEmpty"),
  };
  if (!els.loadBtn) return;

  const COLORS = ["#6ee7ff", "#f97316", "#8b5cf6"];
  const AVG_COLOR = "#f97316";
  const ELEMENTS = [
    { code: "01", label: "Aposentadorias, Reserva Remunerada e Reformas" },
    { code: "03", label: "Pensões" },
    { code: "04", label: "Contratação por Tempo Determinado" },
    { code: "05", label: "Outros Benefícios Previdenciários do servidor ou do militar" },
    { code: "06", label: "Benefício Mensal ao Deficiente e ao Idoso" },
    { code: "07", label: "Contribuição a Entidades Fechadas de Previdência" },
    { code: "08", label: "Outros Benefícios Assistenciais do servidor e do militar" },
    { code: "09", label: "Salário-Família" },
    { code: "10", label: "Seguro Desemprego e Abono Salarial" },
    { code: "11", label: "Vencimentos e Vantagens Fixas - Pessoal Civil" },
    { code: "12", label: "Vencimentos e Vantagens Fixas - Pessoal Militar" },
    { code: "13", label: "Obrigações Patronais" },
    { code: "14", label: "Diárias - Civil" },
    { code: "15", label: "Diárias - Militar" },
    { code: "16", label: "Outras Despesas Variáveis - Pessoal Civil" },
    { code: "17", label: "Outras Despesas Variáveis - Pessoal Militar" },
    { code: "18", label: "Auxílio Financeiro a Estudantes" },
    { code: "19", label: "Auxílio-Fardamento" },
    { code: "20", label: "Auxílio Financeiro a Pesquisadores" },
    { code: "21", label: "Juros sobre a Dívida por Contrato" },
    { code: "22", label: "Outros Encargos sobre a Dívida por Contrato" },
    { code: "23", label: "Juros, Deságios e Descontos da Dívida Mobiliária" },
    { code: "24", label: "Outros Encargos sobre a Dívida Mobiliária" },
    { code: "25", label: "Encargos sobre Operações de Crédito por Antecipação da Receita" },
    { code: "26", label: "Obrigações decorrentes de Política Monetária" },
    { code: "27", label: "Encargos pela Honra de Avais, Garantias, Seguros e Similares" },
    { code: "28", label: "Remuneração de Cotas de Fundos Autárquicos" },
    { code: "29", label: "Distribuição de Resultado de Empresas Estatais Dependentes" },
    { code: "30", label: "Material de Consumo" },
    { code: "31", label: "Premiações Culturais, Artísticas, Científicas, Desportivas e Outras" },
    { code: "32", label: "Material, Bem ou Serviço para Distribuição Gratuita" },
    { code: "33", label: "Passagens e Despesas com Locomoção" },
    { code: "34", label: "Outras Despesas de Pessoal decorrentes de Contratos de Terceirização" },
    { code: "35", label: "Serviços de Consultoria" },
    { code: "36", label: "Outros Serviços de Terceiros - Pessoa Física" },
    { code: "37", label: "Locação de Mão-de-Obra" },
    { code: "38", label: "Arrendamento Mercantil" },
    { code: "39", label: "Outros Serviços de Terceiros - Pessoa Jurídica" },
    { code: "40", label: "Serviços de Tecnologia da Informação e Comunicação - Pessoa Jurídica" },
    { code: "41", label: "Contribuições" },
    { code: "42", label: "Auxílios" },
    { code: "43", label: "Subvenções Sociais" },
    { code: "45", label: "Subvenções Econômicas" },
    { code: "46", label: "Auxílio-Alimentação" },
    { code: "47", label: "Obrigações Tributárias e Contributivas" },
    { code: "48", label: "Outros Auxílios Financeiros a Pessoas Físicas" },
    { code: "49", label: "Auxílio-Transporte" },
    { code: "51", label: "Obras e Instalações" },
    { code: "52", label: "Equipamentos e Material Permanente" },
    { code: "53", label: "Aposentadorias do RGPS - Área Rural" },
    { code: "54", label: "Aposentadorias do RGPS - Área Urbana" },
    { code: "55", label: "Pensões do RGPS - Área Rural" },
    { code: "56", label: "Pensões do RGPS - Área Urbana" },
    { code: "57", label: "Outros Benefícios do RGPS - Área Rural" },
    { code: "58", label: "Outros Benefícios do RGPS - Área Urbana" },
    { code: "59", label: "Pensões Especiais" },
    { code: "61", label: "Aquisição de Imóveis" },
    { code: "62", label: "Aquisição de Produtos para Revenda" },
    { code: "63", label: "Aquisição de Títulos de Crédito" },
    { code: "64", label: "Aquisição de Títulos Representativos de Capital já Integralizado" },
    { code: "65", label: "Constituição ou Aumento de Capital de Empresas" },
    { code: "66", label: "Concessão de Empréstimos e Financiamentos" },
    { code: "67", label: "Depósitos Compulsórios" },
    { code: "70", label: "Rateio pela Participação em Consórcio Público" },
    { code: "71", label: "Principal da Dívida Contratual Resgatado" },
    { code: "72", label: "Principal da Dívida Mobiliária Resgatado" },
    { code: "73", label: "Correção Monetária ou Cambial da Dívida Contratual Resgatada" },
    { code: "74", label: "Correção Monetária ou Cambial da Dívida Mobiliária Resgatada" },
    { code: "75", label: "Correção Monetária da Dívida de Operações de Crédito por Antecipação de Receita" },
    { code: "76", label: "Principal Corrigido da Dívida Mobiliária Refinanciado" },
    { code: "77", label: "Principal Corrigido da Dívida Contratual Refinanciado" },
    { code: "81", label: "Distribuição Constitucional ou Legal de Receitas" },
    { code: "82", label: "Aporte de Recursos pelo Parceiro Público em Favor do Parceiro Privado Decorrente de Contrato de PPP" },
    { code: "83", label: "Despesas Decorrentes de Contrato de PPP, exceto Subvenções Econômicas, Aporte e Fundo Garantidor" },
    { code: "84", label: "Despesas Decorrentes da Participação em Fundos, Organismos, ou Entidades Assemelhadas, Nacionais e Internacionais" },
    { code: "85", label: "Contrato de Gestão" },
    { code: "86", label: "Compensações a Regimes de Previdência" },
    { code: "91", label: "Sentenças Judiciais" },
    { code: "92", label: "Despesas de Exercícios Anteriores" },
    { code: "93", label: "Indenizações e Restituições" },
    { code: "94", label: "Indenizações e Restituições Trabalhistas" },
    { code: "95", label: "Indenização pela Execução de Trabalhos de Campo" },
    { code: "96", label: "Ressarcimento de Despesas de Pessoal Requisitado" },
    { code: "97", label: "Aporte para Cobertura do Déficit Atuarial do RPPS" },
    { code: "98", label: "Despesa do Orçamento de Investimento" },
    { code: "99", label: "A Classificar" },
  ];
  const selectedElementCodes = new Set(["30", "36", "39"]);
  let expenseSeries = [];
  let expenseElementTotals = [];
  let selectedElementYears = new Set();
  let elementChartState = { bars: [], plot: null, avgValue: 0 };
  let hideZeroElements = false;

  function showError(msg){
    els.error.style.display = msg ? "block" : "none";
    els.error.textContent = msg || "";
  }

  function mountExpenseCanvas(){
    if (!els.chart) return;
    els.chart.innerHTML = "";
    const c = document.createElement("canvas");
    c.className = "chartCanvas";
    c.dataset.role = "chart";
    els.chart.appendChild(c);
  }

  function getExpenseCanvas(){
    return els.chart?.querySelector("canvas[data-role='chart']");
  }

  function fitExpenseCanvas(canvas){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(300, Math.floor(rect.width));
    const h = Math.max(220, Math.floor(rect.height));
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return {ctx, w, h};
  }

  function getNiceStep(rawStep){
    if (rawStep <= 0) return 1;
    const magnitude = 10 ** Math.floor(Math.log10(rawStep));
    const normalized = rawStep / magnitude;
    let step = 10;
    if (normalized <= 1) step = 1;
    else if (normalized <= 2) step = 2;
    else if (normalized <= 5) step = 5;
    return step * magnitude;
  }

  function hideElementTooltip(){
    if (els.elementTooltip){
      els.elementTooltip.style.opacity = "0";
    }
  }

  function showElementTooltip(content, x, y){
    if (!els.elementTooltip) return;
    els.elementTooltip.innerHTML = content;
    els.elementTooltip.style.left = `${x}px`;
    els.elementTooltip.style.top = `${y}px`;
    els.elementTooltip.style.opacity = "1";
  }

  function handleElementChartHover(event){
    const canvas = getExpenseElementCanvas();
    if (!canvas || !els.elementTooltip || !elementChartState.bars.length) return;
    const canvasRect = canvas.getBoundingClientRect();
    const wrapRect = els.elementChart.getBoundingClientRect();
    const cursorX = event.clientX - canvasRect.left;
    const cursorY = event.clientY - canvasRect.top;
    const hit = elementChartState.bars.find((bar) =>
      cursorX >= bar.x &&
      cursorX <= bar.x + bar.w &&
      cursorY >= bar.y &&
      cursorY <= bar.y + bar.h
    );
    const offsetX = canvasRect.left - wrapRect.left;
    const offsetY = canvasRect.top - wrapRect.top;
    const tooltipX = offsetX + cursorX;
    const tooltipY = offsetY + cursorY;
    if (hit){
      showElementTooltip(`<strong>${hit.element.label}</strong>${hit.year}: ${moneyBR(hit.value)}`, tooltipX, tooltipY);
      return;
    }
    const plot = elementChartState.plot;
    if (!plot){
      hideElementTooltip();
      return;
    }
    const isInsidePlot = cursorX >= plot.x && cursorX <= plot.x + plot.w && cursorY >= plot.y && cursorY <= plot.y + plot.h;
    if (!isInsidePlot || !elementChartState.avgValue){
      hideElementTooltip();
      return;
    }
    showElementTooltip(`<strong>Média</strong>${moneyBR(elementChartState.avgValue)}`, tooltipX, tooltipY);
  }

  function mountExpenseElementCanvas(){
    if (!els.elementChart) return;
    els.elementChart.innerHTML = "";
    const c = document.createElement("canvas");
    c.className = "chartCanvas";
    c.dataset.role = "chart-element";
    els.elementChart.appendChild(c);
    c.addEventListener("mousemove", handleElementChartHover);
    c.addEventListener("mouseleave", hideElementTooltip);
  }

  function getExpenseElementCanvas(){
    return els.elementChart?.querySelector("canvas[data-role='chart-element']");
  }

  function parseExpenseDate(value){
    if (!value) return null;
    if (value instanceof Date && !isNaN(value)){
      return value;
    }
    if (typeof value === "number" && window.XLSX?.SSF?.parse_date_code){
      const date = XLSX.SSF.parse_date_code(value);
      if (date && date.y && date.m && date.d){
        return new Date(date.y, date.m - 1, date.d);
      }
    }
    const str = value.toString().trim();
    if (!str) return null;
    const brMatch = str.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
    if (brMatch){
      return new Date(Number(brMatch[3]), Number(brMatch[2]) - 1, Number(brMatch[1]));
    }
    const isoMatch = str.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})/);
    if (isoMatch){
      return new Date(Number(isoMatch[1]), Number(isoMatch[2]) - 1, Number(isoMatch[3]));
    }
    return null;
  }

  function normalizeHeader(header){
    return normalizeText(header).replace(/\s+/g, " ");
  }

  function extractElementCode(value){
    if (!value) return "";
    const parts = value.toString().match(/\d+/g) || [];
    if (!parts.length) return "";
    if (parts.length >= 2){
      return parts[parts.length - 2].padStart(2, "0");
    }
    const digits = parts[0];
    if (digits.length >= 2) return digits.slice(-2);
    return digits.padStart(2, "0");
  }

  function mapExpenseRows(rows, forcedYear){
    if (!rows.length) return [];
    const header = rows[0].map((cell) => normalizeHeader(cell || ""));
    const findIndex = (options) => header.findIndex((h) => options.includes(h));
    const idxDate = findIndex(["data"]);
    const idxValor = findIndex(["valor"]);
    const idxNatureza = findIndex(["natureza da despesa", "natureza", "natureza despesa", "nat despesa"]);
    if (idxDate < 0 || idxValor < 0){
      throw new Error("Cabeçalho inválido. Certifique-se de ter colunas DATA e VALOR.");
    }
    const rowsOut = [];
    for (let i = 1; i < rows.length; i++){
      const row = rows[i];
      if (!row || row.every((cell) => (cell ?? "").toString().trim() === "")) continue;
      const dateValue = parseExpenseDate(row[idxDate]);
      if (!dateValue) continue;
      const year = forcedYear ? Number(forcedYear) : dateValue.getFullYear();
      if (!year) continue;
      const valueRaw = row[idxValor];
      const value = parseBRNumber(valueRaw);
      if (!value) continue;
      const natureza = idxNatureza >= 0 ? row[idxNatureza] : "";
      const element = extractElementCode(natureza);
      rowsOut.push({ year, month: dateValue.getMonth(), value, element });
    }
    return rowsOut;
  }

  async function readExpenseFile(file){
    const ext = (file.name.split(".").pop() || "").toLowerCase();
    if (ext === "xlsx" || ext === "xls"){
      const buffer = await file.arrayBuffer();
      const workbook = XLSX.read(buffer, { type: "array" });
      const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
      return XLSX.utils.sheet_to_json(firstSheet, { header: 1, defval: "" });
    }
    const text = await file.text();
    return parseCSV(text).rows;
  }

  function buildSeries(rows){
    const map = new Map();
    for (const row of rows){
      if (!map.has(row.year)){
        map.set(row.year, new Array(12).fill(0));
      }
      map.get(row.year)[row.month] += row.value;
    }
    return Array.from(map.entries())
      .sort((a, b) => a[0] - b[0])
      .map(([year, values]) => ({ year, values }));
  }

  function buildElementTotals(rows){
    const map = new Map();
    for (const row of rows){
      if (!row.element) continue;
      if (!map.has(row.year)){
        map.set(row.year, {});
      }
      const entry = map.get(row.year);
      entry[row.element] = (entry[row.element] || 0) + row.value;
    }
    return Array.from(map.entries())
      .sort((a, b) => a[0] - b[0])
      .map(([year, totals]) => ({ year, totals }));
  }

  function getAvailableElementYears(){
    return expenseElementTotals.map((serie) => serie.year);
  }

  function getComparisonYears(){
    if (!expenseElementTotals.length) return [];
    const years = getAvailableElementYears();
    if (!selectedElementYears.size) return [];
    return years.filter((year) => selectedElementYears.has(year));
  }

  function buildElementComparisonSeries(years = getComparisonYears()){
    return years.map((year) => {
      const found = expenseElementTotals.find((serie) => serie.year === year);
      return { year, totals: found ? found.totals : {} };
    });
  }

  function getElementTotalForYears(elementCode, years){
    if (!years.length) return 0;
    return years.reduce((acc, year) => {
      const serie = expenseElementTotals.find((entry) => entry.year === year);
      return acc + (serie?.totals[elementCode] || 0);
    }, 0);
  }

  function renderLegend(series){
    els.legend.innerHTML = "";
    const frag = document.createDocumentFragment();
    series.forEach((serie, idx) => {
      const item = document.createElement("div");
      item.className = "expenseLegendItem";
      const swatch = document.createElement("span");
      swatch.className = "expenseLegendSwatch";
      swatch.style.background = COLORS[idx % COLORS.length];
      item.appendChild(swatch);
      const label = document.createElement("span");
      label.textContent = serie.year;
      item.appendChild(label);
      frag.appendChild(item);
    });
    els.legend.appendChild(frag);
  }

  function renderElementLegend(years){
    if (!els.elementLegend) return;
    els.elementLegend.innerHTML = "";
    const frag = document.createDocumentFragment();
    years.forEach((year) => {
      const item = document.createElement("button");
      item.type = "button";
      item.className = "expenseLegendItem expenseLegendToggle";
      const isSelected = selectedElementYears.has(year);
      item.classList.toggle("is-off", !isSelected);
      item.setAttribute("aria-pressed", isSelected ? "true" : "false");
      const swatch = document.createElement("span");
      swatch.className = "expenseLegendSwatch";
      swatch.style.background = getElementYearColor(year);
      item.appendChild(swatch);
      const label = document.createElement("span");
      label.textContent = year;
      item.appendChild(label);
      item.addEventListener("click", () => {
        if (selectedElementYears.has(year)){
          selectedElementYears.delete(year);
        } else {
          selectedElementYears.add(year);
        }
        renderElementLegend(years);
        renderElementOptions();
        drawExpenseElementChart();
      });
      frag.appendChild(item);
    });
    els.elementLegend.appendChild(frag);
  }

  function renderElementOptions(){
    if (!els.elementOptions) return;
    const years = getComparisonYears();
    const query = normalizeText(els.elementSearch?.value || "");
    const matches = ELEMENTS.filter((element) => {
      if (!query) return true;
      const haystack = normalizeText(`${element.code} ${element.label}`);
      return haystack.includes(query);
    }).filter((element) => {
      if (!hideZeroElements || !years.length) return true;
      return getElementTotalForYears(element.code, years) > 0;
    });
    els.elementOptions.innerHTML = "";
    const frag = document.createDocumentFragment();
    matches.forEach((element) => {
      const label = document.createElement("label");
      label.className = "expenseFilterOption";
      const input = document.createElement("input");
      input.type = "checkbox";
      input.dataset.element = element.code;
      input.checked = selectedElementCodes.has(element.code);
      input.addEventListener("change", () => {
        if (input.checked){
          selectedElementCodes.add(element.code);
        } else {
          selectedElementCodes.delete(element.code);
        }
        renderElementOptions();
        drawExpenseElementChart();
      });
      label.appendChild(input);
      const text = document.createElement("span");
      text.textContent = `${element.code} • ${element.label}`;
      label.appendChild(text);
      frag.appendChild(label);
    });
    els.elementOptions.appendChild(frag);

    if (els.elementEmpty){
      if (matches.length){
        els.elementEmpty.style.display = "none";
      } else {
        els.elementEmpty.textContent = "Nenhum elemento encontrado.";
        els.elementEmpty.style.display = "block";
      }
    }
  }

  function getSelectedElements(){
    return ELEMENTS.filter((element) => selectedElementCodes.has(element.code));
  }

  function updateElementSummary(selectedElements){
    if (!els.elementSummary) return;
    if (!expenseElementTotals.length){
      els.elementSummary.textContent = "Nenhum dado de despesas carregado.";
      return;
    }
    const years = getComparisonYears();
    if (!years.length){
      els.elementSummary.textContent = "Selecione pelo menos um ano.";
      return;
    }
    if (!selectedElements.length){
      els.elementSummary.textContent = "Selecione pelo menos um elemento.";
      return;
    }
    const total = selectedElements.reduce((acc, element) => {
      return acc + getElementTotalForYears(element.code, years);
    }, 0);
    const avgDivisor = Math.max(1, selectedElements.length * Math.max(1, years.length));
    const avg = total / avgDivisor;
    els.elementSummary.textContent = `Total selecionado: ${moneyBR(total)} • Média simples (filtros): ${moneyBR(avg)}`;
  }

  function getElementAverage(selectedElements, comparisonSeries){
    if (!selectedElements.length || !comparisonSeries.length) return 0;
    const total = selectedElements.reduce((acc, element) => acc + (element.total || 0), 0);
    return total / (selectedElements.length * comparisonSeries.length);
  }

  function getElementYearColor(year){
    const years = getAvailableElementYears();
    const index = years.indexOf(year);
    return COLORS[(index >= 0 ? index : 0) % COLORS.length];
  }

  function drawExpenseChart(){
    const canvas = getExpenseCanvas();
    if (!canvas) return;
    const { ctx, w, h } = fitExpenseCanvas(canvas);
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = "rgba(0,0,0,.08)";
    ctx.fillRect(0, 0, w, h);
    ctx.strokeStyle = "rgba(255,255,255,.08)";
    ctx.strokeRect(0.5, 0.5, w - 1, h - 1);

    const padding = { top: 24, right: 18, bottom: 36, left: 48 };
    const plot = {
      x: padding.left,
      y: padding.top,
      w: w - padding.left - padding.right,
      h: h - padding.top - padding.bottom,
    };

    ctx.strokeStyle = "rgba(255,255,255,.08)";
    ctx.beginPath();
    ctx.moveTo(plot.x, plot.y);
    ctx.lineTo(plot.x, plot.y + plot.h);
    ctx.lineTo(plot.x + plot.w, plot.y + plot.h);
    ctx.stroke();

    const maxValue = Math.max(1, ...expenseSeries.flatMap((serie) => serie.values));
    const yMax = maxValue * 1.1;
    ctx.fillStyle = "rgba(233,238,252,.65)";
    ctx.font = "11px system-ui";
    for (let i = 0; i <= 4; i++){
      const yVal = yMax * (1 - i / 4);
      const y = plot.y + (plot.h * i) / 4;
      ctx.fillText(moneyBR(yVal), 6, y + 4);
      ctx.strokeStyle = "rgba(255,255,255,.05)";
      ctx.beginPath();
      ctx.moveTo(plot.x, y);
      ctx.lineTo(plot.x + plot.w, y);
      ctx.stroke();
    }

    const monthLabels = MONTHS.map((m) => m.label.slice(0, 3));
    const stepX = plot.w / (monthLabels.length - 1);
    ctx.fillStyle = "rgba(233,238,252,.7)";
    monthLabels.forEach((label, idx) => {
      const x = plot.x + stepX * idx;
      ctx.fillText(label, x - 10, plot.y + plot.h + 22);
    });

    expenseSeries.forEach((serie, idx) => {
      ctx.strokeStyle = COLORS[idx % COLORS.length];
      ctx.lineWidth = 2;
      ctx.beginPath();
      serie.values.forEach((val, monthIdx) => {
        const x = plot.x + stepX * monthIdx;
        const y = plot.y + plot.h - (val / yMax) * plot.h;
        if (monthIdx === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
      ctx.fillStyle = COLORS[idx % COLORS.length];
      serie.values.forEach((val, monthIdx) => {
        const x = plot.x + stepX * monthIdx;
        const y = plot.y + plot.h - (val / yMax) * plot.h;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      });
    });
  }

  function drawExpenseElementChart(){
    const canvas = getExpenseElementCanvas();
    if (!canvas) return;
    const comparisonSeries = buildElementComparisonSeries();
    const { ctx, w, h } = fitExpenseCanvas(canvas);
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = "rgba(0,0,0,.08)";
    ctx.fillRect(0, 0, w, h);
    ctx.strokeStyle = "rgba(255,255,255,.08)";
    ctx.strokeRect(0.5, 0.5, w - 1, h - 1);

    const selectedElements = getSelectedElements()
      .map((element) => {
        const total = getElementTotalForYears(element.code, getComparisonYears());
        return { ...element, total };
      })
      .sort((a, b) => b.total - a.total);
    const avgValue = getElementAverage(selectedElements, comparisonSeries);
    updateElementSummary(selectedElements);

    if (!comparisonSeries.length){
      ctx.fillStyle = "rgba(233,238,252,.7)";
      ctx.font = "12px system-ui";
      ctx.textAlign = "center";
      ctx.fillText("Selecione pelo menos um ano.", w / 2, h / 2);
      elementChartState = { bars: [], plot: null, avgValue: 0 };
      hideElementTooltip();
      return;
    }

    if (!selectedElements.length){
      ctx.fillStyle = "rgba(233,238,252,.7)";
      ctx.font = "12px system-ui";
      ctx.textAlign = "center";
      ctx.fillText("Sem dados para exibir.", w / 2, h / 2);
      elementChartState = { bars: [], plot: null, avgValue: 0 };
      hideElementTooltip();
      return;
    }

    const padding = { top: 24, right: 20, bottom: 48, left: 60 };
    const plot = {
      x: padding.left,
      y: padding.top,
      w: w - padding.left - padding.right,
      h: h - padding.top - padding.bottom,
    };

    const maxValue = Math.max(
      1,
      ...comparisonSeries.flatMap((serie) =>
        selectedElements.map((element) => serie.totals[element.code] || 0)
      )
    );
    const bufferedMax = maxValue * 1.05;
    const yStep = getNiceStep(bufferedMax / 4);
    const yMax = yStep * 4;

    ctx.strokeStyle = "rgba(255,255,255,.08)";
    ctx.beginPath();
    ctx.moveTo(plot.x, plot.y);
    ctx.lineTo(plot.x, plot.y + plot.h);
    ctx.lineTo(plot.x + plot.w, plot.y + plot.h);
    ctx.stroke();

    ctx.fillStyle = "rgba(233,238,252,.65)";
    ctx.font = "11px system-ui";
    for (let i = 0; i <= 4; i++){
      const yVal = yMax - yStep * i;
      const y = plot.y + (plot.h * i) / 4;
      ctx.fillText(moneyBR(yVal), 6, y + 4);
      ctx.strokeStyle = "rgba(255,255,255,.05)";
      ctx.beginPath();
      ctx.moveTo(plot.x, y);
      ctx.lineTo(plot.x + plot.w, y);
      ctx.stroke();
    }

    if (avgValue > 0){
      const avgY = plot.y + plot.h - (avgValue / yMax) * plot.h;
      ctx.strokeStyle = AVG_COLOR;
      ctx.lineWidth = 1.5;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      ctx.moveTo(plot.x, avgY);
      ctx.lineTo(plot.x + plot.w, avgY);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    const groupCount = selectedElements.length;
    const seriesCount = comparisonSeries.length;
    const groupWidth = plot.w / Math.max(1, groupCount);
    const barGap = 8;
    const maxBarWidth = 26;
    const availableWidth = Math.max(1, groupWidth - barGap);
    const barWidth = Math.min(maxBarWidth, availableWidth / Math.max(1, seriesCount));
    const bars = [];

    selectedElements.forEach((element, elementIdx) => {
      const groupX = plot.x + elementIdx * groupWidth + (groupWidth - barWidth * seriesCount) / 2;
      comparisonSeries.forEach((serie, serieIdx) => {
        const value = serie.totals[element.code] || 0;
        const barHeight = (value / yMax) * plot.h;
        const x = groupX + serieIdx * barWidth;
        const y = plot.y + plot.h - barHeight;
        ctx.fillStyle = getElementYearColor(serie.year);
        const barActualWidth = barWidth - 2;
        ctx.fillRect(x, y, barActualWidth, barHeight);
        bars.push({
          x,
          y,
          w: barActualWidth,
          h: barHeight,
          value,
          year: serie.year,
          element,
        });
      });
      ctx.fillStyle = "rgba(233,238,252,.8)";
      ctx.font = "12px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(element.code, plot.x + elementIdx * groupWidth + groupWidth / 2, plot.y + plot.h + 10);
    });
    elementChartState = { bars, plot: { ...plot }, yMax, avgValue };
  }

  async function handleExpenseLoad(){
    showError("");
    const files = [
      { file: els.file1.files[0], year: els.year1.value.trim() },
      { file: els.file2.files[0], year: els.year2.value.trim() },
      { file: els.file3.files[0], year: els.year3.value.trim() },
    ].filter((item) => item.file);

    if (!files.length){
      showError("Selecione pelo menos um arquivo de despesas.");
      return;
    }

    try{
      const allSeries = [];
      const allRows = [];
      for (const fileInfo of files){
        const rows = await readExpenseFile(fileInfo.file);
        const parsed = mapExpenseRows(rows, fileInfo.year);
        const series = buildSeries(parsed);
        allSeries.push(...series);
        allRows.push(...parsed);
      }
      const uniqueYears = new Set();
      expenseSeries = allSeries.filter((serie) => {
        if (uniqueYears.has(serie.year)) return false;
        uniqueYears.add(serie.year);
        return true;
      }).slice(0, 3);

      if (!expenseSeries.length){
        showError("Nenhum dado válido encontrado. Verifique o formato e o ano informado.");
        els.status.textContent = "Nenhum arquivo carregado";
        renderLegend([]);
        selectedElementYears = new Set();
        renderElementLegend([]);
        expenseElementTotals = [];
        drawExpenseChart();
        drawExpenseElementChart();
        return;
      }

      els.status.textContent = `Dados carregados: ${expenseSeries.map((s) => s.year).join(" / ")}`;
      renderLegend(expenseSeries);
      expenseElementTotals = buildElementTotals(allRows).filter((serie) =>
        expenseSeries.some((yearSerie) => yearSerie.year === serie.year)
      );
      const availableYears = getAvailableElementYears();
      selectedElementYears = new Set(availableYears);
      renderElementLegend(availableYears);
      renderElementOptions();
      drawExpenseChart();
      drawExpenseElementChart();
    }catch(err){
      showError(err?.message || "Erro ao processar o arquivo.");
      els.status.textContent = "Nenhum arquivo carregado";
      expenseElementTotals = [];
      selectedElementYears = new Set();
      renderElementLegend([]);
      drawExpenseElementChart();
    }
  }

  mountExpenseCanvas();
  mountExpenseElementCanvas();
  els.loadBtn.addEventListener("click", handleExpenseLoad);
  if (els.elementSearch){
    els.elementSearch.addEventListener("input", renderElementOptions);
  }
  if (els.elementSelectAll){
    els.elementSelectAll.addEventListener("click", () => {
      const years = getComparisonYears();
      ELEMENTS.forEach((element) => {
        if (hideZeroElements && years.length && getElementTotalForYears(element.code, years) === 0) return;
        selectedElementCodes.add(element.code);
      });
      renderElementOptions();
      drawExpenseElementChart();
    });
  }
  if (els.elementRemoveZero){
    els.elementRemoveZero.addEventListener("click", () => {
      hideZeroElements = !hideZeroElements;
      els.elementRemoveZero.classList.toggle("active", hideZeroElements);
      if (hideZeroElements){
        const years = getComparisonYears();
        ELEMENTS.forEach((element) => {
          if (years.length && getElementTotalForYears(element.code, years) === 0){
            selectedElementCodes.delete(element.code);
          }
        });
      }
      renderElementOptions();
      drawExpenseElementChart();
    });
  }
  if (els.elementClear){
    els.elementClear.addEventListener("click", () => {
      selectedElementCodes.clear();
      renderElementOptions();
      drawExpenseElementChart();
    });
  }
  renderElementOptions();
  window.addEventListener("resize", () => {
    drawExpenseChart();
    drawExpenseElementChart();
  });
  drawExpenseChart();
  drawExpenseElementChart();
}

tabPanels.forEach((panel) => {
  if (panel.dataset.tab !== "2") return;
  initExpenses(panel);
});

const themeToggles = document.querySelectorAll(".themeToggle");
const themeMeta = document.querySelector('meta[name="theme-color"]');
const THEME_KEY = "dashboard-theme";

function applyTheme(theme){
  const isLight = theme === "light";
  document.body.dataset.theme = isLight ? "light" : "dark";
  if (themeToggles.length){
    themeToggles.forEach((toggle) => {
      toggle.textContent = isLight ? "Tema: Claro" : "Tema: Escuro";
      toggle.setAttribute("aria-pressed", isLight ? "true" : "false");
    });
  }
  if (themeMeta){
    themeMeta.setAttribute("content", isLight ? "#f8fafc" : "#0b1020");
  }
}

const storedTheme = localStorage.getItem(THEME_KEY);
applyTheme(storedTheme === "light" ? "light" : "dark");

if (themeToggles.length){
  themeToggles.forEach((toggle) => {
    toggle.addEventListener("click", () => {
      const nextTheme = document.body.dataset.theme === "light" ? "dark" : "light";
      localStorage.setItem(THEME_KEY, nextTheme);
      applyTheme(nextTheme);
    });
  });
}

const tabButtons = Array.from(document.querySelectorAll(".tabBtn"));
function setActiveTab(tabId){
  tabButtons.forEach(btn => {
    const isActive = btn.dataset.tab === tabId;
    btn.classList.toggle("active", isActive);
    btn.setAttribute("aria-selected", isActive ? "true" : "false");
  });
  tabPanels.forEach(panel => {
    panel.classList.toggle("active", panel.dataset.tab === tabId);
  });
  window.dispatchEvent(new Event("resize"));
}

tabButtons.forEach(btn => {
  btn.addEventListener("click", () => setActiveTab(btn.dataset.tab));
});

setActiveTab("1");

const expenseMenuButtons = Array.from(document.querySelectorAll(".expenseMenuBtn"));
function setExpenseView(view){
  const panels = Array.from(document.querySelectorAll(".expenseContent"));
  panels.forEach((panel) => {
    panel.classList.toggle("active", panel.dataset.expenseView === view);
  });
  window.dispatchEvent(new Event("resize"));
}
expenseMenuButtons.forEach((btn) => {
  btn.addEventListener("click", () => {
    const parentNav = btn.closest(".expenseMenu");
    const scopeButtons = parentNav
      ? Array.from(parentNav.querySelectorAll(".expenseMenuBtn"))
      : expenseMenuButtons;
    scopeButtons.forEach((item) => {
      const isActive = item === btn;
      item.classList.toggle("active", isActive);
      item.setAttribute("aria-current", isActive ? "page" : "false");
    });
    if (btn.dataset.expenseView){
      setExpenseView(btn.dataset.expenseView);
    }
  });
});
if (expenseMenuButtons.length){
  const activeBtn = expenseMenuButtons.find((btn) => btn.classList.contains("active"));
  if (activeBtn?.dataset.expenseView){
    setExpenseView(activeBtn.dataset.expenseView);
  }
}
</script>

<!-- PWA: registro do Service Worker (necessário para instalar como App) -->
<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./sw.js").catch(console.warn);
    });
  }
</script>

</body>
</html>
